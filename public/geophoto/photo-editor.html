<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>FireOpsSim — Photo Viewer & Editor (DB path → Storage)</title>
<style>
  :root{--bg:#0b1220;--card:#111a2e;--muted:#b8c4e2;--line:#1b2b50;--ink:#e8eefc;--accent:#2c5cff;--ok:#7CFF7C;--bad:#FF7C7C}
  *{box-sizing:border-box}
  body{margin:0;padding:16px;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Arial}
  h1{margin:0 0 10px;font-size:20px}
  h2{margin:8px 0 10px;font-size:16px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0}
  input,button,select,label{background:#091125;color:var(--ink);border:1px solid #20407a;border-radius:10px;padding:10px 12px}
  label.switch{display:flex;align-items:center;gap:8px;border:none;padding:0;background:transparent}
  input[type="checkbox"]{width:auto;height:auto}
  button{cursor:pointer}
  button.primary{background:#1a3fbb;border-color:var(--accent)}
  .card{background:var(--card);border:1px solid #1b2b50;border-radius:14px;padding:12px;margin:12px 0}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  #status{white-space:pre-wrap;background:#0c1530;border:1px solid #1b2b50;border-radius:10px;padding:10px;max-height:300px;overflow:auto}

  #scenarios{max-height:260px;overflow:auto;border:1px solid #1b2b50;border-radius:10px}
  .scenario{padding:10px;border-bottom:1px solid #1b2b50;display:flex;gap:10px;align-items:center;justify-content:space-between}
  .scenario:last-child{border-bottom:none}
  .scenario .meta{display:flex;flex-direction:column}
  .scenario .name{font-weight:600}
  .scenario .small{font-size:12px;color:#99a8d8}

  #thumbs{display:grid;grid-template-columns:repeat(auto-fill,minmax(110px,1fr));gap:10px}
  #thumbs a{display:block}
  #thumbs img{width:100%;height:110px;object-fit:cover;border-radius:10px;border:1px solid #1a2b50}
  #empty{color:#9ab0e6}
  .pill{font-size:12px;padding:4px 8px;border:1px solid #2b3d70;border-radius:999px}

  /* Editor modal */
  #editorOverlay{position:fixed;inset:0;background:rgba(6,10,20,.92);display:none;z-index:9999}
  #editor{position:absolute;inset:20px;display:flex;flex-direction:column;gap:10px}
  #editorHeader{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
  #editorHeader .left{display:flex;gap:8px;align-items:center}
  #editorHeader .right{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #editorStage{flex:1;min-height:260px;display:flex;align-items:center;justify-content:center;border:1px solid #1b2b50;border-radius:12px;background:#0b1428;padding:8px;overflow:hidden}
  #stageWrap{position:relative;max-width:100%;max-height:100%}
  canvas#editCanvas{max-width:100%;max-height:100%;border:1px solid #1b2b50;border-radius:8px;background:#000}
  #cropRect{position:absolute;border:2px dashed #2c5cff;background:rgba(44,92,255,.12);display:none;pointer-events:none}
  .navBtns{display:flex;gap:6px}
  .spinner{display:none;position:absolute;inset:0;align-items:center;justify-content:center;background:rgba(10,15,30,.6)}
  .spinner::after{content:"";width:36px;height:36px;border-radius:50%;border:4px solid #3a4b80;border-top-color:#2c5cff;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  @media (max-width:560px){ .row{flex-direction:column;align-items:stretch} input,select,button{width:100%} #editorHeader{flex-direction:column;align-items:stretch;gap:8px} .navBtns button{flex:1} }
</style>
</head>
<body>
  <h1>FireOpsSim — Photo Viewer & Editor</h1>

  <div class="card">
    <div class="row">
      <div class="muted">Realtime DB:</div><div class="mono">dailyquiz-d5279</div>
      <div class="muted">Storage:</div><div class="mono">gs://fireopssim.appspot.com</div>
      <span class="pill">Reads paths from DB → loads from Storage</span>
    </div>
    <div class="row">
      <button id="btnRefreshScenarios" class="primary">Refresh Scenarios</button>
      <input id="filter" placeholder="Filter by name or ID…"/>
    </div>
    <div id="scenarios"><div class="muted" style="padding:10px">Loading…</div></div>
  </div>

  <div class="card">
    <h2>Selected Scenario</h2>
    <div class="row">
      <label class="muted">Scenario ID</label>
      <input id="selectedId" class="mono" readonly placeholder="(none)"/>
    </div>
    <div class="row">
      <button id="btnLoadFromDB" class="primary">Load Photos from DB</button>
      <button id="btnListFromStorage">List from Storage</button>
      <button id="btnOpenUploader">Open Uploader</button>
    </div>
    <div class="row">
      <div class="muted">Storage folder:</div>
      <div class="mono" id="folderPath">scenarios/(none)</div>
    </div>
    <div id="thumbs"></div>
    <div id="empty" class="muted" style="display:none">No photos found.</div>
  </div>

  <div class="card">
    <strong>Status</strong>
    <div id="status">Booting…</div>
  </div>

  <!-- EDITOR MODAL -->
  <div id="editorOverlay" aria-hidden="true">
    <div id="editor">
      <div id="editorHeader">
        <div class="left">
          <div class="navBtns">
            <button id="btnPrev">◀ Prev</button>
            <button id="btnNext">Next ▶</button>
          </div>
          <strong id="editTitle">Editor</strong>
          <span class="muted mono" id="editInfo"></span>
        </div>
        <div class="right">
          <label class="switch" title="If on, edited copy is saved into the same folder as the original">
            <input type="checkbox" id="saveSameFolder" checked> Save in same folder
          </label>
          <button id="btnRotateCW">Rotate 90°</button>
          <button id="btnFlipH">Flip H</button>
          <button id="btnFlipV">Flip V</button>
          <button id="btnCrop">Crop</button>
          <button id="btnDraw">Draw</button>
          <button id="btnUndo">Undo</button>
          <button id="btnReset">Reset</button>
          <button id="btnSave" class="primary">Save as New</button>
          <button id="btnClose">Close</button>
        </div>
      </div>
      <div id="editorStage">
        <div id="stageWrap">
          <canvas id="editCanvas"></canvas>
          <div id="cropRect"></div>
          <div id="busy" class="spinner" aria-hidden="true"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-storage-compat.js"></script>

  <script>
  (function(){
    // ===== helpers =====
    const $ = s=>document.querySelector(s);
    const logEl = $('#status'), scenariosEl = $('#scenarios'), thumbsEl = $('#thumbs'),
          emptyEl = $('#empty'), folderPathEl = $('#folderPath');

    function log(m,c){ const d=document.createElement('div'); if(c)d.style.color=c; d.textContent='['+new Date().toLocaleTimeString()+'] '+m; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight; console.log(m); }
    const ok = m=>log(m,'#7CFF7C'); const bad = m=>log(m,'#FF7C7C');
    const esc = s=>String(s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    const fmtDate = ts=>{try{return new Date(ts).toLocaleString();}catch(_){return String(ts||'');}};
    window.addEventListener('error', e => bad('Script error: '+(e.message||e.error||'unknown')));

    // ===== Firebase (DB app + Storage app) =====
    const dbCfg = { apiKey:"AIzaSyDM6DpRSeZueVKRpbyJyDmhf8WY66KyCDk", authDomain:"dailyquiz-d5279.firebaseapp.com", databaseURL:"https://dailyquiz-d5279-default-rtdb.firebaseio.com", projectId:"dailyquiz-d5279", storageBucket:"dailyquiz-d5279.appspot.com", appId:"1:94577748034:web:c032d3a1d72db1313de5db" };
    const stCfg = { apiKey:"AIzaSyBzwc75u8pG73OKcHN8ti2ADbucjKMHme8", authDomain:"fireopssim.firebaseapp.com", projectId:"fireopssim", storageBucket:"fireopssim.appspot.com", appId:"1:396140888722:web:demo" };

    const dbApp = firebase.initializeApp(dbCfg, 'dbApp');
    const stApp = firebase.initializeApp(stCfg, 'stApp');
    const rtdb = firebase.database(dbApp);
    const dbAuth = firebase.auth(dbApp);
    const stAuth = firebase.auth(stApp);
    const storage = firebase.storage(stApp, "gs://fireopssim.appspot.com");

    async function ensureAuth(){
      if (!dbAuth.currentUser){ const a=await dbAuth.signInAnonymously(); ok('DB auth OK (uid='+(a.user?.uid||'unknown')+')'); }
      if (!stAuth.currentUser){ const b=await stAuth.signInAnonymously(); ok('Storage auth OK (uid='+(b.user?.uid||'unknown')+')'); }
    }

    // ===== scenario listing (explicit orderByKey + fallback) =====
    async function fetchScenarios(){
      try{
        const snap = await rtdb.ref('scenarios').orderByKey().limitToLast(200).once('value');
        const val = snap.val() || {};
        if (Object.keys(val).length) return normalizeScenarioRows(val);
      }catch(e){
        bad('RTDB /scenarios read error: '+(e.code||'')+' '+(e.message||e));
      }
      try{
        const snap2 = await rtdb.ref('geophoto/scenarios').orderByKey().limitToLast(200).once('value');
        const val2 = snap2.val() || {};
        if (Object.keys(val2).length){
          ok('Falling back to /geophoto/scenarios'); 
          return normalizeScenarioRows(val2);
        }
      }catch(e){
        bad('RTDB /geophoto/scenarios read error: '+(e.code||'')+' '+(e.message||e));
      }
      return [];
    }

    function normalizeScenarioRows(valObj){
      return Object.keys(valObj).map(k=>{
        const v = valObj[k] || {};
        return {
          id: v.id || k,
          title: v.title || v.name || '(untitled)',
          createdAt: v.createdAt || v.created || v.time || 0,
          dispatch: v.dispatch || v.description || ''
        };
      }).sort((a,b)=>(b.createdAt||0)-(a.createdAt||0) || String(b.id).localeCompare(String(a.id)));
    }

    function renderScenarioList(rows){
      const filter = ($('#filter').value||'').toLowerCase().trim();
      const filtered = rows.filter(r => !filter || (r.id||'').toLowerCase().includes(filter) || (r.title||'').toLowerCase().includes(filter));

      scenariosEl.innerHTML = '';
      if (!filtered.length){
        scenariosEl.innerHTML = '<div class="muted" style="padding:10px">No scenarios found.</div>';
        return;
      }
      filtered.forEach(r=>{
        const div = document.createElement('div');
        div.className = 'scenario';
        div.innerHTML = `
          <div class="meta">
            <div class="name">${esc(r.title)}</div>
            <div class="small mono">${esc(r.id)} • ${esc(fmtDate(r.createdAt))}</div>
            ${r.dispatch ? `<div class="small">${esc(r.dispatch)}</div>` : ''}
          </div>
          <div><button class="primary btnView" data-id="${esc(r.id)}">View</button></div>`;
        scenariosEl.appendChild(div);
      });
      scenariosEl.querySelectorAll('.btnView').forEach(btn=>{
        btn.addEventListener('click', ()=> selectScenario(btn.getAttribute('data-id')));
      });
    }

    async function listScenarios(){
      try{
        await ensureAuth();
        scenariosEl.innerHTML = '<div class="muted" style="padding:10px">Loading scenarios…</div>';
        const rows = await fetchScenarios();
        renderScenarioList(rows);
        ok(`Loaded ${rows.length} scenario(s).`);
      }catch(e){
        scenariosEl.innerHTML = '<div class="muted" style="padding:10px">Failed to load scenarios.</div>';
        bad('List scenarios error: '+(e.message||e));
      }
    }

    // ===== thumbnails & editor =====
    let currentScenarioId = null;
    let currentFolderList = []; // [{path, url?}] we derive URL from path for thumbs
    let currentIndex = -1;

    function extractStoragePathFromURL(url){
      try{
        const m = /\/o\/([^?]+)/.exec(url);
        if (!m) return null;
        return decodeURIComponent(m[1]); // "scenarios/<sid>/file.jpg"
      }catch(_){ return null; }
    }

    async function selectScenario(id){
      $('#selectedId').value = id || '';
      folderPathEl.textContent = id ? `scenarios/${id}` : 'scenarios/(none)';
      thumbsEl.innerHTML = '';
      emptyEl.style.display = 'none';
      currentScenarioId = id || null;
      currentFolderList = [];
      currentIndex = -1;
      if (id) await loadPhotosFromDB(id);
    }

    // ---- Load photos strictly from DB paths ----
    async function loadPhotosFromDB(id){
      try{
        await ensureAuth();
        thumbsEl.innerHTML = '<div class="muted">Loading photos from DB…</div>';

        let photosSnap = await rtdb.ref(`scenarios/${id}/photos`).orderByKey().limitToLast(500).once('value');
        let photos = photosSnap.val();
        if (!photos){
          photosSnap = await rtdb.ref(`geophoto/scenarios/${id}/photos`).orderByKey().limitToLast(500).once('value');
          photos = photosSnap.val();
        }
        const arr = photos ? Object.values(photos) : [];

        if (!arr.length){ thumbsEl.innerHTML=''; emptyEl.style.display=''; ok('No DB-recorded photos.'); return; }

        arr.sort((a,b)=> (b.createdAt||0)-(a.createdAt||0));
        currentFolderList = arr.map(p=>{
          const path = p.storagePath || extractStoragePathFromURL(p.downloadURL || p.url || '') || null;
          return path ? { path } : null;
        }).filter(Boolean);

        await renderThumbsFromPaths(currentFolderList);
        ok(`Loaded ${currentFolderList.length} photo(s) from DB.`);
      }catch(e){
        thumbsEl.innerHTML=''; emptyEl.style.display='';
        bad('Load-from-DB error: '+(e.code||'')+' '+(e.message||e));
      }
    }

    // ---- (Optional) list directly from Storage folder ----
    async function listFromStorage(){
      const id = $('#selectedId').value;
      if (!id){ alert('Select a scenario first.'); return; }
      try{
        await ensureAuth();
        thumbsEl.innerHTML = '<div class="muted">Listing from Storage…</div>';
        const folderRef = storage.ref().child(`scenarios/${id}`);
        const { items } = await folderRef.listAll();
        if (!items.length){ thumbsEl.innerHTML=''; emptyEl.style.display=''; ok('No objects in Storage folder.'); return; }
        items.sort((a,b)=> (b.name||'').localeCompare(a.name||''));
        currentFolderList = items.map(it => ({ path: it.fullPath }));
        await renderThumbsFromPaths(currentFolderList);
        ok(`Listed ${items.length} photo(s) from Storage.`);
      }catch(e){
        thumbsEl.innerHTML=''; emptyEl.style.display='';
        if (String(e).includes('storage/unauthorized')) bad('Storage denied read.');
        else bad('List-from-Storage error: '+(e.code||'')+' '+(e.message||e));
      }
    }

    // ---- Thumbnails from path (derive fresh URL) ----
    async function renderThumbsFromPaths(list){
      thumbsEl.innerHTML = '';
      if (!list.length){ emptyEl.style.display=''; return; }
      emptyEl.style.display='none';

      const anchors = list.map((item, idx)=>{
        const a = document.createElement('a');
        a.href = 'javascript:void(0)';
        a.dataset.idx = String(idx);
        a.innerHTML = `<img alt="photo" aria-busy="true">`;
        a.addEventListener('click', ()=> openEditorByIndex(idx));
        thumbsEl.appendChild(a);
        return a;
      });

      await Promise.all(list.map(async (item, i)=>{
        try{
          const ref = storage.ref().child(item.path);
          const url = await ref.getDownloadURL(); // just for thumbnail
          item.url = url;
          const img = anchors[i].querySelector('img');
          img.src = url;
          img.removeAttribute('aria-busy');
        }catch(e){
          anchors[i].style.opacity = 0.5;
          anchors[i].title = 'Unable to preview';
          console.warn('Thumb URL error for', item.path, e);
        }
      }));
    }

    // ===== Editor (bytes via getBytes) — NO popups =====
    const overlay = $('#editorOverlay');
    const canvas  = $('#editCanvas');
    const ctx = canvas.getContext('2d');
    const cropRect = $('#cropRect');
    const busy = $('#busy');
    let history = [];
    let drawMode=false, cropMode=false, isDrawing=false, lastX=0, lastY=0;
    let flipH=false, flipV=false, rotation=0;
    let currentBlobURL=null;

    function showBusy(on){ busy.style.display = on ? 'flex' : 'none'; }
    function pushHistory(){ try{ history.push(canvas.toDataURL('image/png')); if (history.length>20) history.shift(); }catch(_){ } }
    function loadIntoCanvas(img){
      const maxW = window.innerWidth - 80;
      const maxH = window.innerHeight - 220;
      const ratio = Math.min(maxW/img.naturalWidth, maxH/img.naturalHeight, 1);
      const w = Math.round(img.naturalWidth * ratio);
      const h = Math.round(img.naturalHeight * ratio);
      canvas.width = w; canvas.height = h;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(img, 0, 0, w, h);
      pushHistory();
    }

    async function getBlobForItem(item){
      const MAX = 30 * 1024 * 1024; // 30 MB safety
      if (item.path){
        const ref = storage.ref().child(item.path);
        const bytes = await ref.getBytes(MAX);
        const ext = (item.path.split('.').pop()||'').toLowerCase();
        const mime = ext==='png'?'image/png':ext==='webp'?'image/webp':'image/jpeg';
        return new Blob([bytes], { type: mime });
      }
      throw new Error('No storagePath available for this item.');
    }

    async function openEditorByIndex(idx){
      if (!currentFolderList.length) return;
      currentIndex = Math.max(0, Math.min(currentFolderList.length-1, idx));
      const item = currentFolderList[currentIndex];
      await openEditorItem(item);
      updateNavButtons();
    }

    function updateNavButtons(){
      $('#btnPrev').disabled = currentIndex<=0;
      $('#btnNext').disabled = currentIndex>=currentFolderList.length-1;
    }

    async function openEditorItem(item){
      showBusy(true);
      try{
        const blob = await getBlobForItem(item);
        if (currentBlobURL) URL.revokeObjectURL(currentBlobURL);
        currentBlobURL = URL.createObjectURL(blob);

        const img = new Image();
        img.onload = ()=>{
          const fileName = item.path.split('/').pop() || 'image';
          $('#editTitle').textContent = 'Editor';
          $('#editInfo').textContent  = (currentScenarioId ? ('scenarios/'+currentScenarioId) : '') + ' • ' + item.path;
          history.length = 0; drawMode=false; cropMode=false; flipH=false; flipV=false; rotation=0; cropRect.style.display='none';
          loadIntoCanvas(img);
          overlay.style.display = 'block';
          overlay.setAttribute('aria-hidden','false');
          showBusy(false);
        };
        img.onerror = ()=>{
          showBusy(false);
          bad('Failed to render image in editor.');
          alert('Could not render this image in the editor.');
        };
        img.src = currentBlobURL;
      }catch(e){
        showBusy(false);
        bad('Open editor failed: '+(e.code||'')+' '+(e.message||e));
        alert('Could not open this image in the editor.\nCheck storage rules and the recorded storagePath.');
      }
    }

    function closeEditor(){
      overlay.style.display='none';
      overlay.setAttribute('aria-hidden','true');
      if (currentBlobURL){ URL.revokeObjectURL(currentBlobURL); currentBlobURL=null; }
    }

    function redraw(){
      const w = canvas.width, h = canvas.height;
      const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
      const tctx = tmp.getContext('2d'); tctx.drawImage(canvas,0,0);
      ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,w,h);
      ctx.save(); ctx.translate(w/2, h/2);
      if (rotation) ctx.rotate(rotation*Math.PI/180);
      ctx.scale(flipH?-1:1, flipV?-1:1);
      ctx.drawImage(tmp, -w/2, -h/2);
      ctx.restore();
    }
    $('#btnRotateCW').addEventListener('click', ()=>{ rotation=(rotation+90)%360; redraw(); pushHistory(); });
    $('#btnFlipH').addEventListener('click', ()=>{ flipH=!flipH; redraw(); pushHistory(); });
    $('#btnFlipV').addEventListener('click', ()=>{ flipV=!flipV; redraw(); pushHistory(); });

    // Draw mode
    $('#btnDraw').addEventListener('click', ()=>{ drawMode=!drawMode; cropMode=false; cropRect.style.display='none'; });
    canvas.addEventListener('pointerdown', e=>{
      if (!drawMode) return;
      isDrawing = true;
      const r = canvas.getBoundingClientRect(); lastX = e.clientX - r.left; lastY = e.clientY - r.top;
    });
    canvas.addEventListener('pointermove', e=>{
      if (!drawMode || !isDrawing) return;
      const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left; const y = e.clientY - r.top;
      ctx.strokeStyle = '#2c5cff'; ctx.lineWidth = 3; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke();
      lastX=x; lastY=y;
    });
    window.addEventListener('pointerup', ()=>{ if (drawMode && isDrawing){ isDrawing=false; pushHistory(); } });

    // Crop mode
    const cropRectEl = $('#cropRect'); let cropStart=null, cropEnd=null;
    function startCrop(){ drawMode=false; cropMode=true; cropRectEl.style.display=''; cropStart=cropEnd=null; Object.assign(cropRectEl.style,{left:'0',top:'0',width:'0',height:'0'}); }
    $('#btnCrop').addEventListener('click', startCrop);
    $('#stageWrap').addEventListener('pointerdown', e=>{
      if (!cropMode) return;
      const r = canvas.getBoundingClientRect();
      cropStart = { x: Math.max(0, Math.min(canvas.width,  (e.clientX - r.left) * (canvas.width / r.width))),
                    y: Math.max(0, Math.min(canvas.height, (e.clientY - r.top)  * (canvas.height / r.height)))};
      cropEnd = {...cropStart}; positionCropRect();
    });
    $('#stageWrap').addEventListener('pointermove', e=>{
      if (!cropMode || !cropStart) return;
      const r = canvas.getBoundingClientRect();
      cropEnd = { x: Math.max(0, Math.min(canvas.width,  (e.clientX - r.left) * (canvas.width / r.width))),
                  y: Math.max(0, Math.min(canvas.height, (e.clientY - r.top)  * (canvas.height / r.height)))};
      positionCropRect();
    });
    window.addEventListener('pointerup', ()=>{
      if (!cropMode || !cropStart) return;
      const x = Math.min(cropStart.x, cropEnd.x), y = Math.min(cropStart.y, cropEnd.y);
      const w = Math.max(10, Math.abs(cropEnd.x - cropStart.x)), h = Math.max(10, Math.abs(cropEnd.y - cropStart.y));
      const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
      tmp.getContext('2d').drawImage(canvas, x, y, w, h, 0, 0, w, h);
      canvas.width=w; canvas.height=h; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,w,h); ctx.drawImage(tmp,0,0);
      cropMode=false; cropRectEl.style.display='none'; pushHistory();
    });
    function positionCropRect(){
      const r = canvas.getBoundingClientRect();
      const x = Math.min(cropStart.x, cropEnd.x), y = Math.min(cropStart.y, cropEnd.y);
      const w = Math.abs(cropEnd.x - cropStart.x), h = Math.abs(cropEnd.y - cropStart.y);
      const left = r.left + x * (r.width / canvas.width);
      const top  = r.top  + y * (r.height/ canvas.height);
      const ww   = w * (r.width / canvas.width);
      const hh   = h * (r.height/ canvas.height);
      Object.assign(cropRectEl.style,{left:left+'px',top:top+'px',width:ww+'px',height:hh+'px'});
    }

    function undo(){ if (history.length<=1) return; history.pop(); const img = new Image(); img.onload = ()=>{ canvas.width=img.width; canvas.height=img.height; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); }; img.src = history[history.length-1]; }
    function reset(){ drawMode=false; cropMode=false; cropRect.style.display='none'; if (history.length){ const first=new Image(); first.onload=()=>{ canvas.width=first.width; canvas.height=first.height; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(first,0,0); pushHistory(); }; first.src = history[0]; } }
    $('#btnUndo').addEventListener('click', undo);
    $('#btnReset').addEventListener('click', reset);

    function dataUrlToBlob(dataUrl){ const [head,b64]=dataUrl.split(','); const mime=(head.match(/data:(.*);base64/)||[])[1]||'image/jpeg'; const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)u8[i]=bin.charCodeAt(i); return new Blob([u8],{type:mime}); }

    async function saveEdited(){
      try{
        await ensureAuth();
        const sid = $('#selectedId').value.trim();
        if (!sid){ alert('No scenario selected'); return; }
        const item = currentFolderList[currentIndex]; if (!item){ alert('No image loaded'); return; }
        const ts = Date.now();
        const blob = await new Promise(res=> canvas.toBlob(res, 'image/jpeg', 0.92)) || dataUrlToBlob(canvas.toDataURL('image/jpeg',0.92));
        const originalPath = item.path || `scenarios/${sid}`;
        const dir = originalPath.includes('/') ? originalPath.split('/').slice(0,-1).join('/') : `scenarios/${sid}`;
        const baseName = (originalPath.split('/').pop() || 'image.jpg').replace(/\.(jpg|jpeg|png|webp)$/i,'');
        const saveSame = $('#saveSameFolder').checked;
        const targetDir = saveSame ? dir : `${dir}/edited`;
        const fileName = `${baseName}_edited_${ts}.jpg`;
        const path = `${targetDir}/${fileName}`;
        const ref = storage.ref().child(path);
        log('Uploading edited → '+path);
        await ref.put(blob, { contentType:'image/jpeg' });
        ok('Edited image saved.');

        // Post back ONLY the storage path (no URL)
        const payload = { type:'fo-upload-complete', scenarioId: sid, storagePath: path, gsUri: `gs://fireopssim.appspot.com/${path}`, contentType:'image/jpeg', createdAt: ts };
        if (window.opener) window.opener.postMessage(payload, "*");
        else if (window.parent) window.parent.postMessage(payload, "*");

        // Update local list & UI
        currentFolderList.splice(currentIndex+1, 0, { path });
        try{
          const thumbUrl = await ref.getDownloadURL();
          const a=document.createElement('a'); a.href='javascript:void(0)'; a.innerHTML=`<img src="${thumbUrl}" alt="photo">`;
          const newIdx = currentIndex+1;
          a.addEventListener('click', ()=> openEditorByIndex(newIdx));
          thumbsEl.insertBefore(a, thumbsEl.children[newIdx]||null);
        }catch(_){}
        alert('Saved as new image.');
      }catch(e){
        bad('Save error: '+(e.message||e)); alert('Save failed:\n'+(e.message||e));
      }
    }
    $('#btnSave').addEventListener('click', saveEdited);
    $('#btnClose').addEventListener('click', ()=>{ closeEditor(); });

    // Prev / Next
    $('#btnPrev').addEventListener('click', async ()=>{ if (currentIndex>0){ await openEditorByIndex(currentIndex-1); } });
    $('#btnNext').addEventListener('click', async ()=>{ if (currentIndex<currentFolderList.length-1){ await openEditorByIndex(currentIndex+1); } });

    // Top buttons
    $('#btnRefreshScenarios').addEventListener('click', listScenarios);
    $('#filter').addEventListener('input', listScenarios);
    $('#btnLoadFromDB').addEventListener('click', ()=>{ const id=$('#selectedId').value; if(id) loadPhotosFromDB(id); });
    $('#btnListFromStorage').addEventListener('click', listFromStorage);
    const UPLOADER_URL='https://fireopssim.com/geophoto/test-edit-uploader';
    $('#btnOpenUploader').addEventListener('click', ()=>{
      const id=$('#selectedId').value.trim(); if(!id){ alert('Select a scenario first.'); return; }
      const url = new URL(UPLOADER_URL); url.searchParams.set('scenarioId', id);
      window.open(url.toString(), 'fireops_uploader'); ok('Opened uploader for '+id);
    });

    // Auto-select scenario by ?scenarioId=... if present
    function scenarioFromUrl(){
      const qsp = new URLSearchParams(location.search);
      const q = qsp.get('scenarioId'); if (q) return decodeURIComponent(q);
      const hash = (location.hash||'').replace(/^#/, ''); return decodeURIComponent(hash||'');
    }

    // Boot
    (async function boot(){
      try{ await ensureAuth(); }catch(e){ bad('Auth error: '+(e.message||e)); }
      const sid = scenarioFromUrl();
      if (sid){ await selectScenario(sid); }
      else { ok('Ready. Loading scenarios…'); await listScenarios(); }
    })();
  })();
  </script>
</body>
</html>

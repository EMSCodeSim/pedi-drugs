<!-- Place where you want the embedded uploader to appear -->
<div id="uploaderHost" style="border:1px solid #1b2b50;border-radius:12px;overflow:hidden">
  <iframe id="uploaderFrame" src="" title="Camera Uploader"
          style="width:100%;height:520px;border:0;background:#0b1220"></iframe>
</div>

<script>
(function(){
  // ==== CONFIG ====
  const TRUSTED_ORIGIN = location.origin;             // same origin recommended
  const UPLOADER_URL   = "/test-edit-uploader.html";  // path to your working uploader

  // ==== Simple message bus with correlation IDs ====
  const reqs = new Map(); // correlationId -> {resolve, reject, timeout}
  let uploaderReady = false;
  const frame = document.getElementById('uploaderFrame');

  function uuid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }

  function postToUploader(payload){
    if (!frame.contentWindow) throw new Error("uploader frame not available");
    frame.contentWindow.postMessage(payload, TRUSTED_ORIGIN);
  }

  // Listen for messages from uploader
  window.addEventListener("message", async (ev)=>{
    if (ev.origin !== TRUSTED_ORIGIN) return; // security check
    const msg = ev.data || {};
    if (msg.type === "fo-ready"){
      uploaderReady = true;
      // Optionally, pass current scenarioId to uploader to display
      const sid = document.getElementById('scenarioId').value.trim();
      if (sid) postToUploader({ type:"fo-set-scenario", scenarioId: sid });
      return;
    }
    if (msg.type === "fo-upload-complete"){
      // Passive event (legacy). You can still handle it here if you want.
      await recordStop(msg); // writes to Realtime DB
      return;
    }
    if (msg.type === "fo-rpc-res" || msg.type === "fo-rpc-err"){
      const { correlationId } = msg;
      const entry = reqs.get(correlationId);
      if (!entry) return;
      clearTimeout(entry.timeout);
      reqs.delete(correlationId);
      if (msg.type === "fo-rpc-res") entry.resolve(msg.result);
      else entry.reject(new Error(msg.error || "uploader error"));
    }
  });

  // RPC-like helper to “call” the uploader from the builder
  function callUploader(method, params, { timeoutMs=30000 }={}){
    return new Promise((resolve, reject)=>{
      const correlationId = uuid();
      const timeout = setTimeout(()=>{
        reqs.delete(correlationId);
        reject(new Error(`uploader-timeout: ${method}`));
      }, timeoutMs);
      reqs.set(correlationId, {resolve, reject, timeout});
      postToUploader({ type:"fo-rpc", method, params, correlationId });
    });
  }

  // ==== Boot the iframe as soon as builder loads ====
  frame.src = UPLOADER_URL;  // load after DOM ready in case of CSP

  // ==== Public function: start one upload roundtrip ====
  async function startUploadRoundtrip(){
    if (!uploaderReady) throw new Error("uploader not ready yet");
    const sid = document.getElementById('scenarioId').value.trim();
    if (!sid) throw new Error("Create a scenario first");

    // ensure uploader shows current scenario (idempotent)
    postToUploader({ type:"fo-set-scenario", scenarioId: sid });

    // Ask uploader to capture+upload. It returns {url, fullPath, gsUri, gps}
    const result = await callUploader("captureAndUpload", { scenarioId: sid }, { timeoutMs: 120000 });

    // Persist in Realtime DB (your existing working logic)
    await recordStop(result);

    // Done — you can update UI, gallery, etc.
    return result;
  }

  // ==== Your existing DB write (minimal example; re-use your functions) ====
  async function recordStop(msg){
    // assumes db/auth already initialized elsewhere in the page
    // msg: {url, fullPath, gsUri, gps, scenarioId}
    const sid = msg.scenarioId;
    const snap = await firebase.database().ref(`scenarios/${sid}/stops`).get();
    const arr  = snap.exists()? (snap.val()||[]) : [];
    arr.push({
      type:'photo',
      imageURL: msg.url,
      thumbURL: msg.url,
      storagePath: msg.fullPath,
      gsUri: msg.gsUri,
      gps: msg.gps || null,
      backend:'fireops',
      at: Date.now(),
    });
    const multi = {};
    multi[`scenarios/${sid}/stops`] = arr;
    multi[`geophoto/scenarios/${sid}/stops`] = arr;
    await firebase.database().ref().update(multi);
  }

  // ==== Hook your existing Upload button to the new flow ====
  document.getElementById('btnUpload')?.addEventListener('click', async ()=>{
    try{
      const r = await startUploadRoundtrip();
      console.log("Upload+DB OK:", r);
      alert("Upload saved.");
      // refresh your gallery if desired
    }catch(e){
      console.error(e);
      alert(e.message || e);
    }
  });

  // Keep scenarioId in sync with uploader when user creates/changes scenario
  document.getElementById('btnCreate')?.addEventListener('click', ()=>{
    const sid = document.getElementById('scenarioId').value.trim();
    if (sid && uploaderReady) postToUploader({ type:"fo-set-scenario", scenarioId: sid });
  });
})();
</script>

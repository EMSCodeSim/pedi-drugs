<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FireOps SIM ‚Äî Advanced Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f14" />
  <style>
    :root{ --bg:#0b0f14;--bg2:#0e1421;--card:#0f1624;--edge:rgba(255,255,255,.10); --text:#eaf2ff;--muted:#93a0b5;--blue:#0a84ff; }
    *{box-sizing:border-box}
    html,body{
      margin:0;height:100%;color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      background:
        radial-gradient(1400px 700px at 15% -15%, rgba(10,132,255,.28), transparent 60%),
        radial-gradient(1200px 600px at 110% 0%, rgba(255,59,48,.22), transparent 60%),
        linear-gradient(165deg, var(--bg2), var(--bg) 55%)
    }

    .topbar{position:sticky;top:0;z-index:40;background:rgba(12,15,22,.78);backdrop-filter:blur(6px) saturate(120%);border-bottom:1px solid rgba(255,255,255,.08)}
    .topnav{max-width:1300px;margin:0 auto;padding:10px 16px;display:flex;gap:12px;align-items:center}
    .brand{font-weight:900}
    .spacer{flex:1}
    .btn{appearance:none;border:1px solid rgba(255,255,255,.16);background:linear-gradient(180deg,#142238,#0f1930);color:#fff;border-radius:12px;padding:9px 12px;font-weight:800;cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}

    main{max-width:1300px;margin:16px auto 40px;padding:0 16px}
    .app{display:grid;grid-template-columns:360px 1fr;gap:12px;align-items:start}
    .app.toolsCollapsed{grid-template-columns:0 1fr}
    .app.toolsCollapsed #tools{display:none}
    .col{background:var(--card);border:1px solid var(--edge);border-radius:16px;padding:12px;min-height:140px}
    #tools{overflow:auto;max-height:calc(100vh - 160px)}
    .hidden{display:none!important}

    label{display:block;margin:8px 0 6px 2px;font-size:12px;color:var(--muted)}
    .input, select, textarea{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.14);background:#0c1322;color:#eaf2ff}
    textarea{min-height:80px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);color:var(--muted)}

    .thumb{width:72px;height:72px;border-radius:8px;border:1px solid rgba(255,255,255,.14);object-fit:cover;background:#0a1a2a;cursor:pointer}
    .thumb.active{outline:3px solid #2dd4bf}
    #thumbRow{display:flex;gap:8px;overflow:auto;padding:8px;border:1px solid rgba(255,255,255,.12);border-radius:10px;background:#0a1a2a}

    .canvasWrap{position:relative;border:1px solid rgba(255,255,255,.12);border-radius:12px;overflow:hidden;background:#061621}
    #c{width:100%;height:calc(100vh - 280px);display:block}

    .sectionTitle{font-weight:900;margin:6px 0}
    .divider{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .small{font-size:12px;opacity:.85}
    #errbar{position:fixed;left:10px;bottom:10px;background:#2b0d0d;color:#ffd7d7;border:1px solid #7a2b2b;border-radius:12px;padding:8px 12px;display:none;z-index:9999}

    #drawer summary{cursor:pointer;list-style:none;padding:8px 10px;border:1px solid rgba(255,255,255,.14);border-radius:10px;background:#0c1528;font-weight:800}
    #drawer[open] summary{background:#0e1a30}

    #loader{ position:fixed; inset:0; display:none; place-items:center; z-index:99; background:rgba(6,12,20,.55); backdrop-filter:blur(2px) }
    .spinner{ width:42px; height:42px; border-radius:999px; border:4px solid rgba(255,255,255,.25); border-top-color:#fff; animation:spin 1s linear infinite }
    @keyframes spin{ to{ transform:rotate(360deg) } }
    .scanRow{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .scanTable{width:100%;border-collapse:collapse;margin-top:8px}
    .scanTable th,.scanTable td{border:1px solid rgba(255,255,255,.14);padding:6px 8px;font-size:12px}
    .scanTable th{background:#0e1a30;text-align:left}
  </style>
</head>
<body>
  <div id="errbar"></div>
  <div id="loader"><div class="spinner"></div></div>

  <div class="topbar">
    <div class="topnav">
      <div class="brand">FireOps SIM ‚Äî Advanced Editor</div>
      <div class="spacer"></div>
      <span id="authPill" class="pill">Auth: connecting‚Ä¶</span>
      <button id="toggleTools" class="btn">Hide Tools</button>
    </div>
  </div>

  <main>
    <div class="app" id="app">
      <aside class="col" id="tools">
        <details id="drawer" open>
          <summary>Editing Tools (collapse/expand)</summary>
          <div style="margin-top:10px">
            <div class="sectionTitle">Scenario</div>
            <label>Choose scenario</label>
            <select id="scenarioSel"><option value="">Select scenario‚Ä¶</option></select>
            <div class="row" style="margin-top:6px">
              <button class="btn" id="refreshBtn">Refresh</button>
              <button class="btn" id="scanRoots">Scan for Scenarios</button>
              <button class="btn" id="deleteScenario" style="background:#2a0f14;border-color:#7a2b2b">Delete Scenario</button>
              <span id="statusPill" class="pill">Loading‚Ä¶</span>
              <span id="rootPill" class="pill small">root: ‚Ä¶</span>
            </div>
            <div id="scanResults" class="small" style="margin-top:6px"></div>

            <div class="divider"></div>
            <div class="sectionTitle">Stop meta</div>
            <label>Title</label><input class="input" id="stopTitle" />
            <label>Caption</label><textarea id="stopCaption"></textarea>
            <div class="row">
              <div style="flex:1"><label>Latitude</label><input class="input" id="stopLat" /></div>
              <div style="flex:1"><label>Longitude</label><input class="input" id="stopLng" /></div>
            </div>
            <label>Radius (meters)</label><input class="input" id="stopRadius" value="50" />
            <div class="row" style="margin-top:6px">
              <button class="btn" id="useGPS">Use my location</button>
              <button class="btn" id="saveMeta">Save Meta</button>
            </div>
            <div id="metaMsg" class="pill small" style="margin-top:6px">Ready</div>

            <div class="divider"></div>
            <div class="sectionTitle">Overlays</div>
            <div class="row" style="gap:6px; flex-wrap:nowrap; overflow:auto">
              <button class="btn" data-cat="fire">üî• Fire</button>
              <button class="btn" data-cat="smoke">üå´Ô∏è Smoke</button>
              <button class="btn" data-cat="people">üßç People</button>
              <button class="btn" data-cat="cars">üöó Cars</button>
              <button class="btn" data-cat="hazard">‚ö†Ô∏è Hazard</button>
            </div>
            <div id="overlayShelf" style="margin-top:8px; display:grid; grid-template-columns:repeat(3, 1fr); gap:8px"></div>

            <div class="divider"></div>
            <div class="sectionTitle">Brush / Stamps</div>
            <div class="row">
              <button class="btn" id="brushFire">üî• Fire Brush</button>
              <button class="btn" id="brushSmoke">üå´Ô∏è Smoke Brush</button>
              <button class="btn" id="brushErase">üßΩ Erase Stamps</button>
              <button class="btn" id="brushOff">‚úñ Off</button>
            </div>
            <label>Brush Size <span id="brushSizeReadout" class="pill" style="margin-left:6px">120 px</span></label>
            <input id="brushSize" type="range" min="24" max="320" step="4" value="120" />

            <div class="divider"></div>
            <div class="sectionTitle">Text on Photo</div>
            <div class="row"><button class="btn" id="addTextbox">+ Add Text Box</button></div>
            <label>Selected Text</label><textarea id="tbContent" placeholder="Type notes‚Ä¶"></textarea>
            <label>Font Size</label><input id="tbFont" type="range" min="12" max="72" step="1" value="24" />
            <label>Background Opacity</label><input id="tbBgOpacity" type="range" min="0" max="1" step="0.05" value="0.6" />
            <div class="row" style="margin-top:6px">
              <button class="btn" id="tbApply">Apply</button>
              <button class="btn" id="tbDelete" style="background:#2a0f14;border-color:#7a2b2b">Delete</button>
            </div>

            <div class="divider"></div>
            <div class="sectionTitle">Selected Overlay</div>
            <div class="row">
              <button class="btn" id="flipSelH">Flip H</button>
              <button class="btn" id="flipSelV">Flip V</button>
              <button class="btn" id="bringFront">Bring Front</button>
              <button class="btn" id="sendBack">Send Back</button>
              <button class="btn" id="deleteObj" style="background:#2a0f14;border-color:#7a2b2b">Delete</button>
            </div>

            <div class="divider"></div>
            <div class="sectionTitle">Export / Save</div>
            <div class="row">
              <button class="btn" id="exportPNG">Export PNG/JPEG</button>
              <button class="btn" id="saveImage">Save Image to Cloud</button>
            </div>

            <!-- AI Generate (beta) -->
            <div class="divider"></div>
            <div class="sectionTitle">AI Generate (beta)</div>
            <label>Return</label>
            <select id="aiReturn" class="input">
              <option value="photo">Composite Photo</option>
              <option value="overlays">Overlays Only (PNG)</option>
            </select>
            <label>Style</label>
            <select id="aiStyle" class="input">
              <option value="realistic">Photo-realistic</option>
              <option value="dramatic">Dramatic Incident</option>
              <option value="training">Training Drill</option>
            </select>
            <label>Scene Notes (optional)</label>
            <textarea id="aiNotes" class="input" placeholder="e.g., light wind from north, 2 occupants, late evening lighting"></textarea>
            <div class="row" style="margin-top:6px">
              <button class="btn" id="aiPreview">Preview Payload</button>
              <button class="btn" id="aiSend">Send to AI</button>
              <button class="btn" id="aiOpen" disabled>Open Result</button>
              <button class="btn" id="aiAdd" disabled>Add as New Stop</button>
            </div>
            <div id="aiMsg" class="pill small" style="margin-top:6px">Idle</div>
          </div>
        </details>
      </aside>

      <section class="col">
        <div class="sectionTitle">Photos in Scenario (click to load in viewer)</div>
        <div id="thumbRow"></div>

        <div class="row" style="margin:10px 0">
          <button class="btn" id="fit">Fit</button>
          <button class="btn" id="zoomIn">Zoom +</button>
          <button class="btn" id="zoomOut">Zoom ‚àí</button>
          <button class="btn" id="rotateL">Rotate ‚ü≥</button>
          <button class="btn" id="rotateR">Rotate ‚ü≤</button>
          <span class="pill" id="canvasInfo">Canvas</span>
        </div>

        <div class="canvasWrap"><canvas id="c"></canvas></div>
      </section>
    </div>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js" crossorigin="anonymous"></script>
  <script type="module">
    /* ---------- tiny helpers ---------- */
    const $ = (id)=>document.getElementById(id);
    const showErr = (m)=>{ const b=$('errbar'); b.textContent=m; b.style.display='block'; };
    const hideErr = ()=>{ $('errbar').style.display='none'; };
    const showLoad = (on)=>{ $('loader').style.display = on ? 'grid' : 'none'; };
    const status = (msg)=>{ $('statusPill').textContent=msg; };
    const setAuthPill = (t)=>{ $('authPill').textContent = `Auth: ${t}`; };

    $('toggleTools').onclick = ()=>{
      const app = $('app');
      const collapse = !app.classList.contains('toolsCollapsed');
      app.classList.toggle('toolsCollapsed', collapse);
      $('toggleTools').textContent = collapse ? 'Show Tools' : 'Hide Tools';
      fitCanvas();
    };

    // ---------- AI function endpoint (primary + fallback) ----------
    const AI_PRIMARY = "/api/ai-image";
    const AI_FALLBACK = "/.netlify/functions/ai-image";
    async function postAI(payload){
      let r = await fetch(AI_PRIMARY, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
      if (r.status === 404) {
        r = await fetch(AI_FALLBACK, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
      }
      return r;
    }

    /* ---------- Firebase ---------- */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getDatabase, ref as dbRef, get, set, onValue, remove } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";
    import {
      getStorage, ref as stRef, uploadBytesResumable, uploadBytes, getDownloadURL,
      getBlob, deleteObject, setMaxUploadRetryTime, setMaxOperationRetryTime
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-storage.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged,
      setPersistence, browserLocalPersistence, browserSessionPersistence, inMemoryPersistence
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";

    const firebaseConfig = {
      apiKey:"AIzaSyDM6DpRSeZueVKRpbyJyDmhf8WY66KyCDk",
      authDomain:"dailyquiz-d5279.firebaseapp.com",
      databaseURL:"https://dailyquiz-d5279-default-rtdb.firebaseio.com",
      projectId:"dailyquiz-d5279",
      storageBucket:"dailyquiz-d5279.firebasestorage.app",
      appId:"1:94577748034:web:c032d3a1d72db1313de5db",
      measurementId:"G-19DVN7NNH7"
    };
    const appFB = initializeApp(firebaseConfig);

    /* -------- Explicit bucket selection (prevents wrong-bucket issues) -------- */
    const EXPLICIT_BUCKET = "dailyquiz-d5279.appspot.com"; // real GCS bucket
    const storage = getStorage(appFB, `gs://${EXPLICIT_BUCKET}`);
    setMaxUploadRetryTime(storage, 5 * 60 * 1000);
    setMaxOperationRetryTime(storage, 5 * 60 * 1000);

    const db = getDatabase(appFB);
    const auth = getAuth(appFB);

    async function ensureAuthed(){
      try{ await setPersistence(auth, browserLocalPersistence); }
      catch{ try{ await setPersistence(auth, browserSessionPersistence); }
      catch{ await setPersistence(auth, inMemoryPersistence); } }
      if (!auth.currentUser){
        await signInAnonymously(auth);
        await new Promise(res=> onAuthStateChanged(auth, u=>u && res(), {once:true}));
      }
      const uid = auth.currentUser.uid.slice(0,8);
      setAuthPill(`anon ‚úî (${uid})`);
      return auth.currentUser;
    }

    /* ---------- Root handling ---------- */
    const FORCE_ROOT = ""; // optional hard override; or use ?root=
    let ROOT = 'scenarios';
    let unsubscribeScenarios = null;

    async function detectRoot(){
      const fromQS = new URLSearchParams(location.search).get('root');
      if (fromQS) return fromQS;
      if (FORCE_ROOT) return FORCE_ROOT;
      await ensureAuthed();

      const probe = async (path) => {
        try {
          const snap = await get(dbRef(db, path));
          const val = snap.exists() ? (snap.val() || {}) : {};
          const count = (val && typeof val === 'object') ? Object.keys(val).length : 0;
          return { path, ok:true, count };
        } catch (e) {
          return { path, ok:false, count:0, error:e };
        }
      };
      const paths = ['geophoto/scenarios', 'scenarios'];
      const results = await Promise.all(paths.map(probe));
      const withData = results.filter(r => r.ok && r.count>0);
      if (withData.length) return withData.sort((a,b)=>b.count-a.count)[0].path;
      const ok = results.find(r => r.ok);
      if (ok) return ok.path;

      showErr(`DB read failed:\n` + results.map(r=>`${r.path}: ${r.error?.code||r.error?.message||r.error}`).join('\n'));
      return 'scenarios';
    }

    function updateRootPill(){
      try {
        $('rootPill').textContent = `root: ${ROOT} | bucket: ${EXPLICIT_BUCKET}`;
      } catch {}
    }

    async function switchRoot(newRoot){
      if (!newRoot || newRoot === ROOT) return;
      ROOT = newRoot;
      updateRootPill();
      if (unsubscribeScenarios) try { unsubscribeScenarios(); } catch {}
      await loadScenarios();
      subscribeScenarios();
    }

    /* ---------- Storage URL helpers (FIXED) ---------- */
    function toStorageRefString(s){
      if(!s) return s;
      let v = s.trim();
      try{ v = decodeURIComponent(v); }catch{}

      // Already gs:// ‚Äî ensure bucket has .appspot.com
      if (v.startsWith('gs://')){
        const m = v.match(/^gs:\/\/([^\/]+)\/?(.*)$/);
        if (m){
          const bucket = m[1].includes('.') ? m[1] : `${m[1]}.appspot.com`;
          const path = m[2] || '';
          return `gs://${bucket}/${path}`;
        }
        return v;
      }

      // googleapis style (safe to coerce)
      let m = v.match(/^https?:\/\/firebasestorage\.googleapis\.com\/v0\/b\/([^/]+)\/o\/([^?]+)/i);
      if (m) return `gs://${m[1]}/${m[2].replace(/\+/g,' ')}`;

      // firebasestorage.app ‚Äî expand to *.appspot.com if coercing
      m = v.match(/^https?:\/\/([^/]+)\.firebasestorage\.app\/o\/([^?]+)/i);
      if (m){
        const bucket = m[1].includes('.') ? m[1] : `${m[1]}.appspot.com`;
        return `gs://${bucket}/${m[2].replace(/\+/g,' ')}`;
      }

      // Any other https: leave as-is (we'll fetch directly)
      return v;
    }

    // Only coerce to gs:// for gs:// or googleapis; keep .app links as HTTPS
    async function getBlobFromRefString(refStr){
      await ensureAuthed();
      if (!refStr) throw new Error('No reference provided');

      let v = refStr.trim();
      try{ v = decodeURIComponent(v); }catch{}

      if (/^gs:\/\//i.test(v)){
        const gs = toStorageRefString(v);
        const ref = stRef(storage, gs);
        return await getBlob(ref);
      }

      if (/^https?:\/\/firebasestorage\.googleapis\.com\//i.test(v)){
        const gs = toStorageRefString(v);
        const ref = stRef(storage, gs);
        return await getBlob(ref);
      }

      // For firebasestorage.app and any other HTTPS, just fetch
      const r = await fetch(v, { mode:'cors', credentials:'omit', cache:'no-store' });
      if (!r.ok) throw new Error('HTTP '+r.status);
      return await r.blob();
    }

    function candidateOriginals(pathOrUrl){
      const out = new Set();
      if (!pathOrUrl) return [];
      let s = pathOrUrl;
      try{ s = decodeURIComponent(s); }catch{}
      const [base, qs] = s.split('?');
      const variants = new Set([base]);
      variants.add(base.replace(/\/thumbs\//i,'/'));
      variants.add(base.replace(/\/thumb_([^/]+)/i, '/$1'));
      variants.add(base.replace(/([-_])(thumb|small|preview|min|tiny)(\.[a-z0-9]+)$/i, '$3'));
      variants.forEach(v=> variants.add(v.replace(/(\.[a-z0-9]+)\1$/i, '$1')));
      for (const v of variants){
        const gs = toStorageRefString(v);
        out.add(gs);
        if (/^https?:\/\//i.test(s) && qs) out.add(`${v}?${qs}`);
      }
      return Array.from(out).filter(Boolean);
    }

    /* ---------- Canvas ---------- */
    const f = new fabric.Canvas('c', { backgroundColor:'#061621', preserveObjectStacking:true });
    let baseImage=null;
    function fitCanvas(){
      const targetH = Math.max(420, window.innerHeight - 280);
      $('c').style.height = targetH + 'px';
      f.setHeight(targetH);
      const viewer = $('c').closest('.col');
      const w = (viewer?.clientWidth || 900) - 24;
      f.setWidth(w);
      if (baseImage && baseImage.type==='rect'){
        baseImage.set({ left:0, top:0, width:f.getWidth(), height:f.getHeight() });
      }
      f.calcOffset(); f.requestRenderAll();
    }
    fitCanvas(); addEventListener('resize', fitCanvas);
    function blobToObjectURL(blob){ return URL.createObjectURL(blob); }
    function revokeURL(u){ try{ URL.revokeObjectURL(u); }catch{} }

    async function setBaseFromBlob(blob){
      return new Promise((resolve,reject)=>{
        const u = blobToObjectURL(blob);
        fabric.Image.fromURL(u, img=>{
          revokeURL(u);
          if(!img){ reject(new Error('Image decode failed')); return; }
          if (baseImage) f.remove(baseImage);
          baseImage = img; baseImage.selectable=false; baseImage.evented=false; baseImage.set('erasable', false);
          const cw=f.getWidth(), ch=f.getHeight();
          const s=Math.min(cw/img.width, ch/img.height);
          img.scale(s); img.set({ left:(cw-img.width*s)/2, top:(ch-img.height*s)/2 });
          f.add(img); img.moveTo(0); f.requestRenderAll();
          $('canvasInfo').textContent=`Image ${Math.round(img.width)}√ó${Math.round(img.height)} | shown ${Math.round(img.width*s)}√ó${Math.round(img.height*s)}`;
          resolve({ naturalW: img.width, naturalH: img.height });
        }, { crossOrigin:'anonymous' });
      });
    }
    async function tryUpgradeIfTiny(stop, dims){
      const minGood = 400;
      if ((dims.naturalW >= minGood) || (dims.naturalH >= minGood)) return true;
      const seeds = [stop.storagePath, stop.gsUri, stop.imageURL].filter(Boolean);
      for (const seed of seeds){
        const candidates = candidateOriginals(seed).slice(0, 6);
        for (const cand of candidates){
          try{
            const blob = await getBlobFromRefString(cand);
            const res = await setBaseFromBlob(blob);
            if (res.naturalW >= minGood || res.naturalH >= minGood){
              if (!stop.storagePath && !/^gs:\/\//.test(cand)) stop.storagePath = cand;
              if (!stop.gsUri && /^gs:\/\//.test(cand)) stop.gsUri = cand;
              await persistStopSource(stop);
              return true;
            }
          }catch(_e){}
        }
      }
      return false;
    }
    async function loadBlobForStop(stop){
      if (stop.gsUri)        return await getBlobFromRefString(stop.gsUri);
      if (stop.storagePath)  return await getBlobFromRefString(stop.storagePath);
      if (typeof stop.imageURL === 'string' && stop.imageURL){
        try{ return await getBlobFromRefString(stop.imageURL); }catch(_e){}
        const r = await fetch(stop.imageURL, { mode:'cors', credentials:'omit', cache:'no-store' });
        if (!r.ok) throw new Error('HTTP '+r.status);
        return await r.blob();
      }
      if (stop.imageData?.data){
        const fmt = stop.imageData.format==='jpeg' ? 'jpeg' : 'png';
        return await (await fetch(`data:image/${fmt};base64,${stop.imageData.data}`)).blob();
      }
      throw new Error('No image source on this stop.');
    }
    async function persistStopSource(stop){
      if (!current || stopIndex<0) return;
      const next = current._stops.slice();
      next[stopIndex] = stop;
      const updated = Object.assign({}, current._raw);
      setStops(updated, next);
      await set(dbRef(db, `${ROOT}/${current.id}`), updated);
      current._raw = updated; current._stops = next;
    }

    /* ---------- Data / scenarios ---------- */
    let scenarios=[], current=null, stopIndex=-1;

    function coerceStops(sc){
      if (Array.isArray(sc?.stops)) return sc.stops;
      if (Array.isArray(sc?.photos)) return sc.photos;
      if (Array.isArray(sc?.images)) return sc.images;
      return [];
    }
    function setStops(sc, stops){
      if (Array.isArray(sc?.stops)) sc.stops = stops;
      else if (Array.isArray(sc?.photos)) sc.photos = stops;
      else if (Array.isArray(sc?.images)) sc.images = stops;
      else sc.stops = stops;
    }
    function populateScenarios(){
      const sel=$('scenarioSel'); sel.innerHTML='<option value="">Select scenario‚Ä¶</option>';
      scenarios.forEach(sc=>{
        const o=document.createElement('option');
        o.value=sc.id; o.textContent=(sc.title||'(untitled)') + (sc.active?'':' (inactive)');
        sel.appendChild(o);
      });
    }

    async function loadScenarios(){
      try{
        await ensureAuthed();
        status('Loading‚Ä¶');
        const snap = await get(dbRef(db, ROOT));
        const obj = snap.exists() ? (snap.val()||{}) : {};
        scenarios = Object.entries(obj).map(([id,s])=>({ id, _raw:s, _stops:coerceStops(s), ...s }))
                    .sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
        populateScenarios();
        status(`${scenarios.length} scenario(s)`);
      }catch(e){
        showErr('Read failed (rules?): ' + (e.message||e));
        status('0 scenario(s)');
      }
    }

    function subscribeScenarios(){
      if (unsubscribeScenarios) try { unsubscribeScenarios(); } catch {}
      const ref = dbRef(db, ROOT);
      unsubscribeScenarios = onValue(ref, snap=>{
        const v=snap.val()||{};
        scenarios = Object.entries(v).map(([id,s])=>({ id, _raw:s, _stops:coerceStops(s), ...s }))
                    .sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
        populateScenarios();
        if (current){
          const fresh=scenarios.find(x=>x.id===current.id);
          if (fresh){ current=fresh; renderThumbs(); }
        }
      }, (err)=>{ showErr('Live updates blocked by rules: '+(err?.message||err)); });
    }

    // ---- Root scanner UI ----
    $('scanRoots').onclick = async ()=>{
      await ensureAuthed();
      const paths = [
        'geophoto/scenarios',
        'scenarios',
        'geophoto/photos',
        'photos',
        'geophoto/images',
        'images',
        'training/scenarios',
        'cases',
        'incidents'
      ];
      const probe = async (path)=>{
        try{
          const snap = await get(dbRef(db, path));
          const val = snap.exists() ? (snap.val()||{}) : {};
          const keys = Object.keys(val);
          const likeSc = keys.filter(k=>{
            const v = val[k];
            return v && typeof v==='object' && (Array.isArray(v.stops)||Array.isArray(v.photos)||Array.isArray(v.images));
          }).length;
          return { path, ok:true, keys:keys.length, likeSc };
        }catch(e){
          return { path, ok:false, err:(e?.code||e?.message||String(e)) };
        }
      };
      const results = await Promise.all(paths.map(probe));
      const el = $('scanResults');
      const rows = results.map(r=>{
        if (!r.ok) return `<tr><td>${r.path}</td><td colspan="2">‚ùå ${r.err}</td><td></td></tr>`;
        const btn = `<button class="btn" data-switch="${r.path}">Use</button>`;
        return `<tr><td>${r.path}</td><td>${r.keys}</td><td>${r.likeSc}</td><td>${btn}</td></tr>`;
      }).join('');
      el.innerHTML = `
        <div class="scanRow"><strong>Root scan:</strong> Click "Use" to switch.</div>
        <table class="scanTable">
          <thead><tr><th>Path</th><th>#keys</th><th>Looks like scenarios</th><th></th></tr></thead>
          <tbody>${rows}</tbody>
        </table>`;
      el.querySelectorAll('button[data-switch]').forEach(b=>{
        b.onclick = async ()=>{ await switchRoot(b.dataset.switch); };
      });
    };

    /* ---------- Thumbnails ---------- */
    function dataURLFromStored(stored){
      return typeof stored==='string'
        ? stored
        : (stored && stored.data ? `data:image/${stored.format||'jpeg'};base64,${stored.data}` : '');
    }
    function renderThumbs(){
      const row=$('thumbRow'); row.innerHTML='';
      if (!current || !current._stops?.length){ row.innerHTML='<div class="pill small">No photos/slides</div>'; return; }
      current._stops.forEach((s,i)=>{
        const thumbSrc = s.thumbURL || s.imageURL || dataURLFromStored(s.imageData) || '';
        const img=document.createElement('img'); img.className='thumb'+(i===stopIndex?' active':'');
        img.src=thumbSrc; img.alt=s.title||('Stop '+(i+1));
        img.onerror=()=>{ img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120"><rect width="100%" height="100%" fill="#000"/><text x="50%" y="52%" fill="#fff" font-size="14" text-anchor="middle">No image</text></svg>`); };
        img.onclick=()=>loadStop(i);
        row.appendChild(img);
      });
    }

    $('scenarioSel').onchange = async ()=>{
      const id=$('scenarioSel').value;
      current=scenarios.find(s=>s.id===id)||null;
      stopIndex=-1;
      renderThumbs();
      f.clear(); baseImage=null; fitCanvas();
      if (current && current._stops.length){ await loadStop(0); }
    };

    async function loadStop(i){
      hideErr();
      if (!current) return;
      const s=current._stops[i]; if(!s) return;
      stopIndex=i;
      Array.from($('thumbRow').children).forEach((n,idx)=> n.classList.toggle('active', idx===i));

      $('stopTitle').value = s.title||'';
      $('stopCaption').value = s.caption||'';
      $('stopLat').value = s.lat??'';
      $('stopLng').value = s.lng??'';
      $('stopRadius').value = (s.radiusMeters ?? s.radius ?? 50);

      f.clear(); baseImage=null;
      if (s.type==='text'){
        setBaseAsTextSlide(s.text||'', s.fontSize||34);
        return;
      }

      try{
        showLoad(true);
        await ensureAuthed();
        const blob = await loadBlobForStop(s);
        const dims = await setBaseFromBlob(blob);
        const ok = await tryUpgradeIfTiny(s, dims);
        if (!ok && (dims.naturalW < 400 || dims.naturalH < 400)){
          showErr('Loaded a small thumbnail. A higher-resolution original could not be found.');
        }
      }catch(e){
        showErr('Image load failed: '+(e.message||e));
      }finally{
        showLoad(false);
      }

      if (Array.isArray(s.overlays)){
        for (const ov of s.overlays){
          if (ov?.kind==='text'){
            const tb = new fabric.Textbox(ov.text||'', {
              left:ov.left||100, top:ov.top||100, scaleX:ov.scaleX||1, scaleY:ov.scaleY||1,
              angle:ov.angle||0, opacity:ov.opacity??1, fontSize:ov.fontSize||24, fill:ov.fill||'#fff',
              backgroundColor:ov.backgroundColor||'rgba(0,0,0,0.6)', padding:ov.padding??8,
              cornerStyle:'circle', transparentCorners:false, editable:true
            }); tb._kind='text'; f.add(tb);
          } else if (ov?.src){
            await new Promise(res=>{
              fabric.Image.fromURL(ov.src, img=>{
                img.set({ left:ov.left||0, top:ov.top||0, scaleX:ov.scaleX||1, scaleY:ov.scaleY||1,
                          angle:ov.angle||0, opacity:ov.opacity??1, flipX:!!ov.flipX, flipY:!!ov.flipY,
                          erasable:true, cornerStyle:'circle', transparentCorners:false });
                f.add(img); res();
              }, { crossOrigin:'anonymous' });
            });
          }
        }
        f.requestRenderAll();
      }
    }

    function setBaseAsTextSlide(text, fontSize){
      f.clear();
      const rect = new fabric.Rect({ left:0, top:0, width:f.getWidth(), height:f.getHeight(), fill:'#000', selectable:false, evented:false, erasable:false });
      baseImage = rect;
      const tb = new fabric.Textbox(text||'', {
        width: Math.floor(f.getWidth()*0.8),
        left: Math.floor(f.getWidth()*0.1),
        top:  Math.floor(f.getHeight()*0.2),
        fontSize: fontSize||34, fill:'#fff', textAlign:'center',
        fontFamily:'system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif',
        selectable:false, evented:false, erasable:false
      });
      tb.isBaseText=true;
      f.add(rect); f.add(tb); rect.moveTo(0); f.requestRenderAll();
      $('canvasInfo').textContent='Text slide';
    }

    /* ---------- Textbox controls ---------- */
    $('addTextbox').onclick = ()=>{
      const tb = new fabric.Textbox('Notes', {
        left: 80, top: 80, width: 320, fontSize: 24, fill:'#fff',
        backgroundColor: 'rgba(0,0,0,0.6)', padding: 8,
        cornerStyle:'circle', transparentCorners:false
      });
      tb._kind='text';
      f.add(tb); f.setActiveObject(tb); f.requestRenderAll();
      $('tbContent').value = tb.text;
      $('tbFont').value = tb.fontSize || 24;
      $('tbBgOpacity').value = 0.6;
    };
    $('tbApply').onclick = ()=>{
      const o = f.getActiveObject();
      if (!o || o.type!=='textbox') return;
      o.text = $('tbContent').value;
      o.fontSize = parseInt($('tbFont').value,10) || 24;
      const op = Math.max(0, Math.min(1, parseFloat($('tbBgOpacity').value)));
      o.backgroundColor = `rgba(0,0,0,${op})`;
      f.requestRenderAll();
    };
    $('tbDelete').onclick = ()=>{
      const o = f.getActiveObject();
      if (o && o.type==='textbox'){ f.remove(o); f.discardActiveObject(); f.requestRenderAll(); }
    };

    function serializeOverlays(){
      const out=[];
      f.getObjects().forEach(o=>{
        if (o===baseImage || o.isBaseText) return;
        if (o.type==='image'){
          out.push({
            kind:'image',
            src:o.getSrc ? o.getSrc() : (o._originalElement?.src || o.src || ''),
            left:o.left||0, top:o.top||0, scaleX:o.scaleX||1, scaleY:o.scaleY||1,
            angle:o.angle||0, opacity:o.opacity??1, flipX:!!o.flipX, flipY:!!o.flipY
          });
        } else if (o.type==='textbox'){
          out.push({
            kind:'text', text:o.text||'', left:o.left||0, top:o.top||0, scaleX:o.scaleX||1, scaleY:o.scaleY||1,
            angle:o.angle||0, opacity:o.opacity??1, fontSize:o.fontSize||24, fill:o.fill||'#fff',
            backgroundColor:o.backgroundColor||'rgba(0,0,0,0.6)', padding:o.padding??8
          });
        }
      });
      return out;
    }

    $('useGPS').onclick = ()=>{
      navigator.geolocation.getCurrentPosition(p=>{
        $('stopLat').value = p.coords.latitude.toFixed(6);
        $('stopLng').value = p.coords.longitude.toFixed(6);
        $('metaMsg').textContent='GPS captured.';
      }, e=>{ $('metaMsg').textContent='GPS error: '+e.message; }, { enableHighAccuracy:true, timeout:10000 });
    };

    $('saveMeta').onclick = async ()=>{
      try{
        await ensureAuthed();
        if(!current || stopIndex<0) throw new Error('Select a stop first.');
        const s = Object.assign({}, current._stops[stopIndex]);
        s.title = $('stopTitle').value.trim();
        s.caption = $('stopCaption').value.trim();
        const lat = $('stopLat').value.trim()==='' ? null : parseFloat($('stopLat').value);
        const lng = $('stopLng').value.trim()==='' ? null : parseFloat($('stopLng').value);
        s.lat = lat; s.lng = lng;
        s.radiusMeters = Math.max(5, Math.min(1000, Math.round(parseInt($('stopRadius').value||'50',10))));
        s.overlays = serializeOverlays();

        const next=current._stops.slice(); next[stopIndex]=s;
        const updated=Object.assign({}, current._raw); setStops(updated,next);
        await set(dbRef(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated; current._stops = next;
        renderThumbs();
        $('metaMsg').textContent='Meta saved.';
      }catch(e){ $('metaMsg').textContent=String(e.message||e); }
    };

    /* ---------- Export / Save ---------- */
    const EDIT_MAX_EDGE=1280, EDIT_THUMB_EDGE=480, EDIT_JPEG_QUALITY=0.85;

    async function dataURLFromCanvasScaled(fabricCanvas, maxEdge=EDIT_MAX_EDGE, quality=EDIT_JPEG_QUALITY){
      const raw = fabricCanvas.toDataURL({ format:'jpeg', quality:1 });
      const img = new Image(); img.decoding = 'async'; img.src = raw; await img.decode();
      const w = img.naturalWidth, h = img.naturalHeight;
      const s = Math.min(1, maxEdge / Math.max(w, h));
      const outW = Math.round(w*s), outH = Math.round(h*s);
      const c = document.createElement('canvas'); c.width = outW; c.height = outH;
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, outW, outH);
      return c.toDataURL('image/jpeg', quality);
    }
    async function thumbFromDataURL(dataURL, maxEdge=EDIT_THUMB_EDGE, q=0.8){
      const img = new Image(); img.decoding='async'; img.src=dataURL; await img.decode();
      const w = img.naturalWidth, h = img.naturalHeight;
      const s = Math.min(1, maxEdge / Math.max(w, h));
      const outW = Math.round(w*s), outH = Math.round(h*s);
      const c = document.createElement('canvas'); c.width=outW; c.height=outH;
      const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(img, 0, 0, outW, outH);
      return c.toDataURL('image/jpeg', q);
    }
    function dataURLtoBlob(dataURL){
      const [head,b64] = dataURL.split(',');
      const mime = (/data:(.*?);base64/.exec(head)||[, 'application/octet-stream'])[1];
      const bin = atob(b64), len = bin.length, buf = new Uint8Array(len);
      for (let i=0;i<len;i++) buf[i] = bin.charCodeAt(i);
      return new Blob([buf], { type:mime });
    }

    async function blobToImage(blob){
      return new Promise((resolve, reject)=>{
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
        img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
        img.decoding='async';
        img.src = url;
      });
    }
    async function reencodeBlobToJPEG(blob, maxEdge=1280, quality=0.85){
      const img = await blobToImage(blob);
      const w = img.naturalWidth, h = img.naturalHeight;
      const s = Math.min(1, maxEdge / Math.max(w, h));
      const outW = Math.max(1, Math.round(w*s)), outH = Math.max(1, Math.round(h*s));
      const c = document.createElement('canvas'); c.width=outW; c.height=outH;
      const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(img, 0, 0, outW, outH);
      return dataURLtoBlob(c.toDataURL('image/jpeg', quality));
    }
    async function uploadWithTimeoutResumable(ref, blob, metadata, timeoutMs=5*60*1000){
      return new Promise((resolve,reject)=>{
        const task = uploadBytesResumable(ref, blob, metadata);
        const killer = setTimeout(()=>{ try{ task.cancel(); }catch{}; reject(Object.assign(new Error('upload/timeout'),{code:'upload/timeout'})); }, timeoutMs);
        task.on('state_changed', ()=>{}, (err)=>{ clearTimeout(killer); reject(err); }, ()=>{ clearTimeout(killer); resolve(); });
      });
    }

    $('exportPNG').onclick = async ()=>{
      const url = await dataURLFromCanvasScaled(f, EDIT_MAX_EDGE, 0.95);
      const a=document.createElement('a'); a.href=url; a.download='image-edited.jpg'; a.click();
    };

    $('saveImage').onclick = async ()=>{
      try{
        if(!current || stopIndex<0) throw new Error('Select a stop first.');
        showLoad(true);
        await ensureAuthed();

        const dataURL      = await dataURLFromCanvasScaled(f, EDIT_MAX_EDGE, EDIT_JPEG_QUALITY);
        const thumbDataURL = await thumbFromDataURL(dataURL, EDIT_THUMB_EDGE, 0.8);

        const fullBlob  = dataURLtoBlob(dataURL);
        const thumbBlob = dataURLtoBlob(thumbDataURL);

        const ts = Date.now();
        const base = `scenarios/${current.id}/${ts}_edited_${stopIndex}`;
        const fullRef  = stRef(storage, `${base}.jpg`);
        const thumbRef = stRef(storage, `scenarios/${current.id}/thumbs/${ts}_edited_${stopIndex}.jpg`);
        const metaFull = { contentType:'image/jpeg', cacheControl:'public,max-age=31536000,immutable' };
        const metaThmb = { contentType:'image/jpeg', cacheControl:'public,max-age=31536000,immutable' };

        await uploadWithTimeoutResumable(fullRef, fullBlob, metaFull);
        try{ await uploadBytes(thumbRef, thumbBlob, metaThmb); }catch(e){ /* non-fatal */ }
        const fullURL  = await getDownloadURL(fullRef);
        const thumbURL = await getDownloadURL(thumbRef).catch(()=>fullURL);

        const s = Object.assign({}, current._stops[stopIndex]);
        const ts2 = Date.now();
        const newStop = {
          type:'photo',
          title: (s.title||'')+' (edited)',
          caption: s.caption||'',
          imageURL: fullURL,
          thumbURL: thumbURL||fullURL,
          storagePath: fullRef.fullPath,
          gsUri: fullRef.fullPath,
          lat: s.lat??null, lng: s.lng??null, accuracy: s.accuracy??null,
          radiusMeters: s.radiusMeters ?? 50,
          overlays: serializeOverlays(),
          at: ts2,
          origin: 'editor'
        };
        const next = current._stops.slice(); next.push(newStop);
        const updated = Object.assign({}, current._raw); setStops(updated, next);
        await set(dbRef(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated; current._stops = next;
        renderThumbs();
        status('Saved edited image ‚úì');
      }catch(e){
        showErr(e.message||String(e));
      }finally{ showLoad(false); }
    };

    $('fit').onclick  = ()=>{
      if (baseImage && baseImage.type==='image'){
        const cw=f.getWidth(), ch=f.getHeight(), s=Math.min(cw/baseImage.width, ch/baseImage.height);
        baseImage.scale(s); baseImage.set({ left:(cw-baseImage.width*s)/2, top:(ch-baseImage.height*s)/2 });
        f.requestRenderAll();
      } else if (baseImage && baseImage.type==='rect'){
        const t=f.getObjects('textbox').find(o=>o.isBaseText);
        setBaseAsTextSlide(t?t.text:'', t?t.fontSize:34);
      }
    };
    $('zoomIn').onclick = ()=> f.setZoom(f.getZoom()*1.1);
    $('zoomOut').onclick= ()=> f.setZoom(f.getZoom()/1.1);
    $('rotateL').onclick = ()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)+90); f.requestRenderAll(); } };
    $('rotateR').onclick = ()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)-90); f.requestRenderAll(); } };

    const OVERLAY_BASE='https://fireopssim.com/geophoto/overlays/';
    const FOLDER={ fire:'fire', smoke:'smoke', people:'people', cars:'cars', hazard:'hazard' };
    const EXT=['png','webp','jpg','jpeg'];

    async function listOverlays(cat){
      try{
        const r = await fetch(`${OVERLAY_BASE}manifest.json`, { cache:'no-store' });
        if (r.ok){ const j = await r.json(); if (Array.isArray(j[FOLDER[cat]])) return j[FOLDER[cat]]; }
      }catch{}
      const prefix = {fire:'fire', smoke:'smoke', people:'person', cars:'car', hazard:'hazard'}[cat]||'img';
      const found=[]; let miss=0;
      for(let i=1;i<=60 && miss<5;i++){
        let hit=false;
        for(const ext of EXT){
          const url = `${OVERLAY_BASE}${FOLDER[cat]}/${prefix}${i}.${ext}`;
          try{ const h=await fetch(url,{method:'HEAD',cache:'no-store'}); if(h.ok){ found.push(`${prefix}${i}.${ext}`); hit=true; break; } }catch{}
        }
        miss = hit ? 0 : miss+1;
      }
      return found;
    }
    function renderShelf(cat){
      const shelf=$('overlayShelf'); shelf.innerHTML='';
      listOverlays(cat).then(files=>{
        if(!files.length){ shelf.innerHTML='<div class="pill small">No overlays found</div>'; return; }
        files.forEach(name=>{
          const url=`${OVERLAY_BASE}${FOLDER[cat]}/${name}`;
          const cell=document.createElement('div'); cell.style.border='1px solid rgba(255,255,255,14)'; cell.style.borderRadius='10px'; cell.style.padding='4px'; cell.style.background='#0b2130';
          const img=new Image(); img.src=url; img.alt=name; img.style.width='100%'; img.style.display='block';
          img.onclick=()=> addOverlay(url);
          cell.appendChild(img); shelf.appendChild(cell);
        });
      });
    }
    function addOverlay(src){
      fabric.Image.fromURL(src, img=>{
        const cw=f.getWidth(), ch=f.getHeight(), targetW=cw*0.28, scale=targetW/img.width;
        img.scale(scale);
        img.set({ left:cw/2-(img.width*img.scaleX)/2, top:ch/2-(img.height*img.scaleY)/2,
                  cornerStyle:'circle', transparentCorners:false, shadow:'rgba(0,0,0,0.35) 0 6px 16px', erasable:true });
        f.add(img); f.setActiveObject(img); f.requestRenderAll();
      }, { crossOrigin:'anonymous' });
    }
    Array.from(document.querySelectorAll('#tools [data-cat]')).forEach(b=>{
      b.addEventListener('click', ()=> renderShelf(b.dataset.cat));
    });
    renderShelf('fire');

    let brushMode='off', pointerDown=false, lastStamp=null;
    const brushSize=$('brushSize'), brushSizeReadout=$('brushSizeReadout');
    brushSize.oninput=()=> brushSizeReadout.textContent=(parseInt(brushSize.value,10)||120)+' px';
    $('brushFire').onclick = ()=> brushMode='fire';
    $('brushSmoke').onclick= ()=> brushMode='smoke';
    $('brushErase').onclick= ()=> brushMode='erase';
    $('brushOff').onclick  = ()=> brushMode='off';
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    async function randomOverlay(cat){
      const files = await listOverlays(cat); if(!files.length) return null;
      const i=Math.floor(Math.random()*files.length);
      return `${OVERLAY_BASE}${FOLDER[cat]}/${files[i]}`;
    }
    async function stampAt(p, cat){
      const file = await randomOverlay(cat); if(!file) return;
      const R = (parseInt(brushSize.value,10)||120)/2;
      if (lastStamp && dist(p,lastStamp) < R*0.6) return; lastStamp=p;
      fabric.Image.fromURL(file, img=>{
        const baseW=img.width||200, scale=(R*2)/baseW, j=0.75+Math.random()*0.5;
        img.scale(scale*j);
        img.set({ left:p.x-(img.width*img.scaleX)/2, top:p.y-(img.height*img.scaleY)/2, angle:(Math.random()*30-15),
                  opacity:0.9, cornerStyle:'circle', transparentCorners:false, erasable:true, selectable:false, evented:false });
        f.add(img); f.requestRenderAll();
      }, { crossOrigin:'anonymous' });
    }
    function eraseStampsAt(p){
      const R=(parseInt(brushSize.value,10)||120)/2;
      const targets = f.getObjects('image').filter(o => o!==baseImage);
      for (const obj of targets){
        const cx=obj.left + (obj.width*obj.scaleX)/2, cy=obj.top + (obj.height*obj.scaleY)/2;
        if (Math.hypot(cx-p.x, cy-p.y) <= R) f.remove(obj);
      }
      f.requestRenderAll();
    }
    f.on('mouse:down', (e)=>{ pointerDown=true; const p=f.getPointer(e.e); if(brushMode==='fire') stampAt(p,'fire'); else if(brushMode==='smoke') stampAt(p,'smoke'); else if(brushMode==='erase') eraseStampsAt(p); });
    f.on('mouse:move', (e)=>{ if(!pointerDown) return; const p=f.getPointer(e.e); if(brushMode==='fire') stampAt(p,'fire'); else if(brushMode==='smoke') stampAt(p,'smoke'); else if(brushMode==='erase') eraseStampsAt(p); });
    f.on('mouse:up', ()=>{ pointerDown=false; });

    $('bringFront').onclick = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.bringToFront(); f.requestRenderAll(); } };
    $('sendBack').onclick  = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.sendToBack(); if(baseImage) baseImage.sendToBack(); f.requestRenderAll(); } };
    $('deleteObj').onclick = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ f.remove(o); f.discardActiveObject(); f.requestRenderAll(); } };
    $('flipSelH').onclick  = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.set('flipX', !o.flipX); f.requestRenderAll(); } };
    $('flipSelV').onclick  = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.set('flipY', !o.flipY); f.requestRenderAll(); } };

    $('deleteScenario').onclick = async ()=>{
      if (!current) return;
      if (!confirm('Delete this scenario and its cloud images?')) return;
      try{
        showLoad(true);
        await ensureAuthed();
        const paths = [];
        (current._stops||[]).forEach(s=>{
          if (s.storagePath) paths.push(s.storagePath);
          if (s.gsUri) paths.push(s.gsUri);
          if (s.imageURL && !/^https?:\/\//.test(s.imageURL)) paths.push(s.imageURL);
        });
        for (const p of paths){
          try{ await deleteObject(stRef(storage, toStorageRefString(p))); }catch(_e){}
        }
        await remove(dbRef(db, `${ROOT}/${current.id}`));
        current=null; stopIndex=-1; populateScenarios(); $('scenarioSel').value=''; $('thumbRow').innerHTML='';
        f.clear(); baseImage=null; fitCanvas();
        status('Scenario deleted.');
      }catch(e){
        showErr('Delete failed: '+(e.message||e));
      }finally{
        showLoad(false);
      }
    };

    /* ---------- AI helpers (mask + inpaint) ---------- */
    function rectCanvasToImage(rect){
      if (!baseImage || baseImage.type!=='image') return { x:0, y:0, w:0, h:0 };
      const sx = baseImage.getScaledWidth()  / baseImage.width;
      const sy = baseImage.getScaledHeight() / baseImage.height;
      const x = (rect.left - baseImage.left) / sx;
      const y = (rect.top  - baseImage.top ) / sy;
      const w = rect.width  / sx;
      const h = rect.height / sy;
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const X = clamp(Math.round(x), 0, Math.round(baseImage.width));
      const Y = clamp(Math.round(y), 0, Math.round(baseImage.height));
      const W = clamp(Math.round(w), 0, Math.round(baseImage.width  - X));
      const H = clamp(Math.round(h), 0, Math.round(baseImage.height - Y));
      return { x:X, y:Y, w:W, h:H };
    }
    function bboxForObject(o){ return rectCanvasToImage(o.getBoundingRect(true, true)); }
    function inferCatFromSrc(src){
      if (!src || typeof src !== 'string') return 'generic';
      const s = src.toLowerCase();
      if (s.includes('/fire/'))   return 'fire';
      if (s.includes('/smoke/'))  return 'smoke';
      if (s.includes('/people/')) return 'people';
      if (s.includes('/cars/'))   return 'cars';
      if (s.includes('/hazard/')) return 'hazard';
      return 'generic';
    }
    function serializeOverlaysForAI(){
      return f.getObjects().filter(o => o!==baseImage && !o.isBaseText).map(o=>{
        if (o.type === 'image'){
          const src = o.getSrc ? o.getSrc() : (o._originalElement?.src || o.src || '');
          return {
            kind: 'image',
            category: inferCatFromSrc(src),
            src,
            bbox: bboxForObject(o),
            angle: o.angle||0,
            opacity: o.opacity??1,
            flipX: !!o.flipX,
            flipY: !!o.flipY,
            z: f.getObjects().indexOf(o)
          };
        } else if (o.type === 'textbox'){
          return {
            kind: 'text',
            text: o.text || '',
            bbox: bboxForObject(o),
            angle: o.angle||0,
            opacity: o.opacity??1,
            fontSize: o.fontSize||24,
            color: o.fill||'#fff',
            bg: o.backgroundColor||'rgba(0,0,0,0.6)',
            z: f.getObjects().indexOf(o)
          };
        }
        return null;
      }).filter(Boolean);
    }
    function buildMaskDataURL(){
      const W = Math.round(baseImage?.width  || 0);
      const H = Math.round(baseImage?.height || 0);
      if (!W || !H) throw new Error('No base image loaded.');
      const c = document.createElement('canvas'); c.width = W; c.height = H;
      const ctx = c.getContext('2d');
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#ffffff';
      const feather = 6;
      const overlays = serializeOverlaysForAI();
      for (const o of overlays){
        const { x, y, w, h } = o.bbox;
        ctx.fillRect(Math.max(0,x-feather), Math.max(0,y-feather),
                     Math.min(W-x+feather, w+2*feather), Math.min(H-y+feather, h+2*feather));
      }
      return { dataUrl: c.toDataURL('image/png'), overlays };
    }
    async function getBaseImageURLForStop(){
      const s = current._stops[stopIndex];
      if (s?.imageURL && /^https?:\/\//i.test(s.imageURL)) return s.imageURL;
      const refStr = s?.storagePath || s?.gsUri;
      if (refStr){
        const ref = stRef(storage, refStr);
        return await getDownloadURL(ref);
      }
      if (s?.imageData?.data){
        return `data:image/${s.imageData.format||'jpeg'};base64,${s.imageData.data}`;
      }
      throw new Error('This stop has no accessible base image.');
    }

    // Upload AI result (URL path)
    async function saveAIResultFromURL(imageUrl){
      let resp;
      try {
        resp = await fetch(imageUrl, { mode:'cors', credentials:'omit', cache:'no-store' });
      } catch (e) {
        $('aiMsg').textContent = `AI returned an unreachable URL (network): ${imageUrl}`;
        return null;
      }
      if (!resp.ok) {
        const txt = await resp.text().catch(()=> "");
        $('aiMsg').textContent = `AI returned a bad URL: ${imageUrl} (${resp.status}) ${txt || ""}`;
        return null;
      }
      const original = await resp.blob();
      let uploadBlob = await reencodeBlobToJPEG(original, 1280, 0.85);

      const ts = Date.now();
      const path = `scenarios/${current.id}/ai/results/${ts}_stop${stopIndex}.jpg`;
      const ref = stRef(storage, path);
      const meta = { contentType: 'image/jpeg', cacheControl: 'public,max-age=31536000,immutable' };

      try { await uploadWithTimeoutResumable(ref, uploadBlob, meta); }
      catch (e) {
        const msg = e?.code || e?.message || String(e);
        if (/retry-limit-exceeded|upload\/timeout/i.test(msg)) {
          $('aiMsg').textContent = 'Upload slow ‚Äî retrying smaller‚Ä¶';
          const smaller = await reencodeBlobToJPEG(original, 960, 0.80);
          await uploadWithTimeoutResumable(ref, smaller, meta);
        } else {
          $('aiMsg').textContent = `Upload failed: ${msg}`;
          return null;
        }
      }

      const url = await getDownloadURL(ref);
      $('aiOpen').disabled = false;
      $('aiAdd').disabled  = false;
      $('aiOpen').onclick = ()=> window.open(url, '_blank');
      $('aiAdd').onclick  = ()=> addResultAsNewStop(url);
      $('aiMsg').textContent = 'Result uploaded ‚úì';
      return url;
    }

    // Upload AI result (data URL path)
    async function saveAIResultToStorage(dataUrl){
      const originalBlob = await (await fetch(dataUrl)).blob();
      let uploadBlob = await reencodeBlobToJPEG(originalBlob, 1280, 0.85);

      const ts = Date.now();
      const path = `scenarios/${current.id}/ai/results/${ts}_stop${stopIndex}.jpg`;
      const ref = stRef(storage, path);
      const meta = { contentType: 'image/jpeg', cacheControl: 'public,max-age=31536000,immutable' };

      try{ await uploadWithTimeoutResumable(ref, uploadBlob, meta); }
      catch(e){
        const msg = e?.code || e?.message || String(e);
        if (/retry-limit-exceeded|upload\/timeout/i.test(msg)) {
          $('aiMsg').textContent = 'Upload slow ‚Äî retrying smaller‚Ä¶';
          const smaller = await reencodeBlobToJPEG(originalBlob, 960, 0.80);
          await uploadWithTimeoutResumable(ref, smaller, meta);
        } else {
          $('aiMsg').textContent = `Upload failed: ${msg}`;
          return null;
        }
      }

      const url = await getDownloadURL(ref);
      $('aiOpen').disabled = false;
      $('aiAdd').disabled  = false;
      $('aiOpen').onclick = ()=> window.open(url, '_blank');
      $('aiAdd').onclick  = ()=> addResultAsNewStop(url);
      $('aiMsg').textContent = 'Result uploaded ‚úì';
      return url;
    }

    async function addResultAsNewStop(url){
      if (!current || stopIndex<0) return;
      const base = current._stops[stopIndex];
      const ts = Date.now();
      const newStop = {
        type:'photo',
        title: (base.title||'') + ' (AI)',
        caption: 'AI composite',
        imageURL: url, thumbURL: url,
        storagePath: null, gsUri: null,
        lat: base.lat ?? null, lng: base.lng ?? null, accuracy: base.accuracy ?? null,
        radiusMeters: base.radiusMeters ?? 50,
        overlays: [],
        at: ts, origin: 'ai', basedOn: stopIndex
      };
      const next = current._stops.slice(); next.push(newStop);
      const updated = Object.assign({}, current._raw); setStops(updated, next);
      await set(dbRef(db, `${ROOT}/${current.id}`), updated);
      current._raw = updated; current._stops = next;
      renderThumbs();
      $('aiMsg').textContent = 'AI image added as a new stop.';
    }

    $('aiPreview').onclick = ()=>{
      try{
        const { dataUrl, overlays } = buildMaskDataURL();
        console.log('[AI] mask preview (dataUrl length):', dataUrl.length, 'overlays:', overlays);
        $('aiMsg').textContent = 'Mask + overlay payload logged to console.';
      }catch(e){
        $('aiMsg').textContent = e.message || String(e);
      }
    };

    /* ---------- Refresh / init ---------- */
    $('refreshBtn').onclick = async ()=>{
      const next = await detectRoot();
      await switchRoot(next);
    };

    (async()=>{
      await ensureAuthed();          // auth first
      ROOT = await detectRoot();
      updateRootPill();
      await loadScenarios();
      subscribeScenarios();
    })();
  </script>
</body>
</html>

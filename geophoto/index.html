<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FireOps SIM ‚Äî Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f14" />
  <style>
    html,body{
      margin:0;padding:0;height:100%;
      background:#0b0f14;color:#eaf2ff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      overflow:hidden
    }
    .topbar{position:sticky;top:0;z-index:50;background:rgba(12,15,22,.78);backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,.07)}
    .topnav{max-width:1100px;margin:0 auto;padding:10px 20px;display:flex;align-items:center;gap:14px}
    .brandmini{display:flex;align-items:center;gap:12px;font-weight:800}
    .logo img{width:40px;height:40px;border-radius:10px;box-shadow:0 12px 34px rgba(0,0,0,.38);background:#0f1624}
    /* App layout */
    #app{position:fixed;top:60px;left:0;right:0;bottom:0;display:grid;grid-template-rows:auto 1fr auto;gap:10px;padding:10px}
    #scenarioRow{display:flex;gap:10px;align-items:center}
    select{flex:1;min-width:200px;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:#0f1624;color:#eaf2ff;outline:none;font-size:16px}
    #note{color:#8ea0b3;font-size:13px}
    /* Full-screen viewer */
    #viewerWrap{position:relative;width:100%;height:100%;border-radius:16px;border:1px solid rgba(255,255,255,.12);background:#000;overflow:hidden}
    #photo{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000}
    #caption{
      position:absolute;left:0;right:0;bottom:0;
      text-align:center;font-size:18px;padding:12px 16px;
      background:linear-gradient(0deg,rgba(0,0,0,.65),transparent);
      display:none
    }
    /* Scenario controls (only place with buttons) */
    #runRow{display:flex;gap:10px;align-items:center;justify-content:flex-start}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:800;cursor:pointer;background:linear-gradient(180deg,#54a6ff,#0a84ff);color:#03131b;box-shadow:0 12px 34px rgba(0,0,0,.38)}
    .btn.secondary{background:transparent;color:#eaf2ff;border:1px solid rgba(255,255,255,.18)}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topnav">
      <div class="brandmini">
        <div class="logo"><img src="/assets/logo/fire-ops-sim.png" alt="FireOps SIM"></div>
        <div>FireOps SIM</div>
      </div>
    </div>
  </div>

  <div id="app">
    <!-- Scenario select & hint -->
    <div id="scenarioRow">
      <select id="scenarioSelect" aria-label="Choose a scenario"><option value="">Loading scenarios‚Ä¶</option></select>
      <span id="note">iPhone: use ‚ÄúRead Text‚Äù to speak. Android/Desktop auto-read; button repeats.</span>
    </div>

    <!-- Viewer (no buttons overlay here) -->
    <div id="viewerWrap" aria-live="polite">
      <img id="photo" alt="Scenario Photo" decoding="async" fetchpriority="high">
      <div id="caption"></div>
    </div>

    <!-- Scenario Controls (only place with buttons) -->
    <div id="runRow">
      <button id="startStop" class="btn">Start</button>
      <button id="readText" class="btn secondary">üîä Read Text</button>
    </div>
  </div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script>

  <script>
  (function(){
    const $ = id => document.getElementById(id);

    const select = $('scenarioSelect');
    const photo = $('photo');
    const caption = $('caption');
    const startStop = $('startStop');
    const readText = $('readText');

    // Device / TTS policy
    const isIOS = /iP(hone|ad|od)/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const synthOK = ('speechSynthesis' in window) && ('SpeechSynthesisUtterance' in window);
    const autoSpeak = !isIOS && synthOK;   // Android/Desktop autoplay; iOS requires button
    let lastSpeech = '';

    // Wake Lock (prevent sleep)
    let wakeLock = null, keepAliveVideo=null;
    async function acquireWakeLock(){
      try{
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', ()=>{ wakeLock=null; });
          return;
        }
      }catch{}
      // iOS fallback: tiny hidden looping video
      if (!keepAliveVideo) {
        keepAliveVideo = document.createElement('video');
        keepAliveVideo.setAttribute('playsinline','');
        keepAliveVideo.muted=true; keepAliveVideo.loop=true;
        keepAliveVideo.src='data:video/mp4;base64,AAAAIGZ0eXBpc29tAAAAAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQA=';
        keepAliveVideo.style.position='fixed'; keepAliveVideo.style.width='1px'; keepAliveVideo.style.height='1px';
        keepAliveVideo.style.opacity='0'; keepAliveVideo.style.pointerEvents='none';
        document.body.appendChild(keepAliveVideo);
      }
      try{ await keepAliveVideo.play(); }catch{}
    }
    async function releaseWakeLock(){
      try{ if (wakeLock) { await wakeLock.release(); wakeLock=null; } }catch{}
      try{ if (keepAliveVideo){ await keepAliveVideo.pause(); } }catch{}
    }

    // Firebase
    const firebaseConfig={apiKey:"AIzaSyDM6DpRSeZueVKRpbyJyDmhf8WY66KyCDk",authDomain:"dailyquiz-d5279.firebaseapp.com",databaseURL:"https://dailyquiz-d5279-default-rtdb.firebaseio.com",projectId:"dailyquiz-d5279",appId:"1:94577748034:web:c032d3a1d72db1313de5db",measurementId:"G-19DVN7NNH7"};
    firebase.initializeApp(firebaseConfig);
    const db=firebase.database();

    // Helpers: new imageData format ‚Üí data URL
    function toDataURL(stored){
      if (!stored) return '';
      if (typeof stored === 'string') return stored;
      if (stored.data){
        const fmt = (stored.format === 'jpeg' || stored.format === 'jpg') ? 'jpeg' : 'png';
        return `data:image/${fmt};base64,${stored.data}`;
      }
      return '';
    }

    // Load scenarios (geophoto/scenarios or scenarios)
    let scenarios=[], current=null, watchId=null, running=false, lastStopIndex=-1;
    function normalizeStops(stopsLike){
      if(!stopsLike) return [];
      const arr = Array.isArray(stopsLike) ? stopsLike : Object.values(stopsLike);
      return arr.map(s=>{
        const num=v=> (v===0||v===null) ? v : parseFloat(v);
        return {
          title: s.title || s.name || '',
          caption: s.caption || s.text || '',
          lat: num(s.lat ?? s.latitude ?? s.latDeg),
          lng: num(s.lng ?? s.lon ?? s.long ?? s.longitude ?? s.lngDeg),
          radiusMeters: num(s.radiusMeters ?? s.radius ?? s.r) || 40,
          image: toDataURL(s.imageData || s.imageURL || s.imageUrl || s.url || s.photoURL || s.photo)
        };
      }).filter(s => typeof s.lat==='number' && typeof s.lng==='number');
    }
    function populateDropdown(list){
      select.innerHTML='<option value="">Select a scenario‚Ä¶</option>';
      list.sort((a,b)=> (b.createdAt||0)-(a.createdAt||0));
      list.forEach(sc=>{
        const o=document.createElement('option');
        o.value=sc.id; o.textContent=sc.title || sc.name || '(untitled)';
        select.appendChild(o);
      });
    }
    function mapSnapshot(val){
      const obj=val||{};
      return Object.entries(obj).map(([id,s])=>({ id, ...(s||{}), stops: normalizeStops(s?.stops) }));
    }
    db.ref('geophoto/scenarios').on('value', snap=>{
      const list=mapSnapshot(snap.val());
      if(list.length){ scenarios=list; populateDropdown(list); }
    });
    db.ref('scenarios').on('value', snap=>{
      const list=mapSnapshot(snap.val());
      if(!scenarios.length && list.length){ scenarios=list; populateDropdown(list); }
    });

    // Geofence math (Haversine)
    const toRad = x => x*Math.PI/180;
    const havDistance=(aLat,aLng,bLat,bLng)=>{
      const R=6371000;
      const dLat=toRad(bLat-aLat), dLng=toRad(bLng-aLng);
      const A=Math.sin(dLat/2)**2 + Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*Math.sin(dLng/2)**2;
      return 2*R*Math.asin(Math.sqrt(A));
    };
    // Tight radius: pad by accuracy but cap the pad to 20 m
    function inside(stop, la, ln, acc){
      const d = havDistance(la, ln, stop.lat, stop.lng);
      const pad = Math.min(Math.max(Number(acc)||0, 0), 20); // <= 20m accuracy padding
      return d <= (Number(stop.radiusMeters)||0) + pad;
    }

    // Audio/Vibration cue on new photo
    function buzz(){
      if ('vibrate' in navigator) {
        try { navigator.vibrate([220, 80, 140]); } catch {}
      }
    }
    let audioCtx=null;
    function beep(){
      try{
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type='square'; o.frequency.value=880; // loudish beep
        g.gain.setValueAtTime(0.001, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.6, audioCtx.currentTime + 0.02);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
        o.connect(g).connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.26);
      }catch{}
    }
    function notifyNewPhoto(){ beep(); buzz(); }

    // UI helpers
    function clearPhoto(){
      photo.src=''; caption.style.display='none'; caption.textContent='';
    }
    function showStop(stop){
      photo.src = stop.image || '';
      const cap = (stop.title ? stop.title + ' ‚Äî ' : '') + (stop.caption || '');
      caption.textContent = cap;
      caption.style.display = cap ? 'block' : 'none';
      lastSpeech = (stop.title ? stop.title + '. ' : '') + (stop.caption || '');
      if (autoSpeak && lastSpeech) speak(lastSpeech);
      notifyNewPhoto();
    }

    // TTS
    function speak(text){
      if (!synthOK || !text) return;
      try { speechSynthesis.cancel(); } catch {}
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1; u.pitch = 1; u.volume = 1;
      try { speechSynthesis.speak(u); } catch {}
    }
    function unlockTTS(){ // one-time gesture for iOS
      if (!synthOK) return;
      try { speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(' '); u.volume = 0; speechSynthesis.speak(u); } catch {}
    }
    readText.addEventListener('click', ()=>{ unlockTTS(); speak(lastSpeech || 'Ready.'); });

    // Start/Stop
    async function start(){
      if (running) return;
      const id = select.value;
      if(!id){ alert('Choose a scenario first.'); return; }
      running = true;
      startStop.textContent = 'Stop';
      await acquireWakeLock();
      current = scenarios.find(s=>s.id===id) || null;
      clearPhoto(); lastStopIndex = -1;

      if (watchId) { try{ navigator.geolocation.clearWatch(watchId); }catch{} }
      try{
        watchId = navigator.geolocation.watchPosition(p=>{
          if (!running || !current) return;
          const { latitude:la, longitude:ln, accuracy:acc } = p.coords;

          // Gather all stops you're inside of, then choose the closest
          const hits = (current.stops||[])
            .map((st, i) => ({i, st, dist: havDistance(la, ln, st.lat, st.lng)}))
            .filter(obj => inside(obj.st, la, ln, acc))
            .sort((a,b)=> a.dist - b.dist);

          if (hits.length === 0) {
            // outside all geofences -> clear display
            if (lastStopIndex !== -1) { clearPhoto(); lastStopIndex = -1; }
            return;
          }

          const best = hits[0];
          if (best.i !== lastStopIndex){
            lastStopIndex = best.i;
            showStop(best.st);
          }
        }, err=>{ /* silent */ }, { enableHighAccuracy:true, maximumAge:0, timeout:20000 });
      }catch(e){ /* silent */ }
    }
    async function stop(){
      running = false;
      startStop.textContent = 'Start';
      try{ navigator.geolocation.clearWatch(watchId); }catch{}
      await releaseWakeLock();
      try{ if (synthOK) speechSynthesis.cancel(); }catch{}
      clearPhoto();
    }
    startStop.addEventListener('click', ()=> running ? stop() : start());

    // Also allow Read Text to unlock audio context on iOS before start
    readText.addEventListener('click', ()=>{ try{ if (audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch{} });

  })();
  </script>
</body>
</html>

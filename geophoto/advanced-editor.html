<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>FireOps SIM ‚Äî Advanced Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#0b0f14" />
<style>
:root{ --bg:#0b0f14;--bg2:#0e1421;--card:#0f1624;--edge:rgba(255,255,255,.10); --text:#eaf2ff;--muted:#93a0b5;--blue:#0a84ff; }
*{box-sizing:border-box}
html,body{margin:0;height:100%;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:
  radial-gradient(1400px 700px at 15% -15%, rgba(10,132,255,.28), transparent 60%),
  radial-gradient(1200px 600px at 110% 0%, rgba(255,59,48,.22), transparent 60%),
  linear-gradient(165deg, var(--bg2), var(--bg) 55%)}

.topbar{position:sticky;top:0;z-index:40;background:rgba(12,15,22,.78);backdrop-filter:blur(6px) saturate(120%);border-bottom:1px solid rgba(255,255,255,.08)}
.topnav{max-width:1300px;margin:0 auto;padding:10px 16px;display:flex;gap:12px;align-items:center}
.brand{font-weight:900}
.spacer{flex:1}
.btn{appearance:none;border:1px solid rgba(255,255,255,.16);background:linear-gradient(180deg,#142238,#0f1930);color:#fff;border-radius:12px;padding:9px 12px;font-weight:800;cursor:pointer}
.btn[disabled]{opacity:.6;cursor:not-allowed}

main{max-width:1300px;margin:16px auto 40px;padding:0 16px}
.app{display:grid;grid-template-columns:360px 1fr;gap:12px;align-items:start}
.app.toolsCollapsed{grid-template-columns:0 1fr}
.app.toolsCollapsed #tools{display:none}
.col{background:var(--card);border:1px solid var(--edge);border-radius:16px;padding:12px;min-height:140px}
#tools{overflow:auto;max-height:calc(100vh - 160px)}
.hidden{display:none!important}

label{display:block;margin:8px 0 6px 2px;font-size:12px;color:var(--muted)}
.input, select, textarea{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.14);background:#0c1322;color:#eaf2ff}
textarea{min-height:80px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);color:var(--muted)}

.thumb{width:72px;height:72px;border-radius:8px;border:1px solid rgba(255,255,255,.14);object-fit:cover;background:#0a1a2a;cursor:pointer}
.thumb.active{outline:3px solid #2dd4bf}
#thumbRow{display:flex;gap:8px;overflow:auto;padding:8px;border:1px solid rgba(255,255,255,.12);border-radius:10px;background:#0a1a2a}

.canvasWrap{position:relative;border:1px solid rgba(255,255,255,.12);border-radius:12px;overflow:hidden;background:#061621}
#c{width:100%;height:calc(100vh - 280px);display:block}

.sectionTitle{font-weight:900;margin:6px 0}
.divider{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
.small{font-size:12px;opacity:.85}
#errbar{position:fixed;left:10px;bottom:10px;background:#2b0d0d;color:#ffd7d7;border:1px solid #7a2b2b;border-radius:12px;padding:8px 12px;display:none;z-index:9999}

/* collapsible drawer */
#drawer summary{cursor:pointer;list-style:none;padding:8px 10px;border:1px solid rgba(255,255,255,.14);border-radius:10px;background:#0c1528;font-weight:800}
#drawer[open] summary{background:#0e1a30}

/* loading overlay */
#loader{ position:fixed; inset:0; display:none; place-items:center; z-index:99; background:rgba(6,12,20,.55); backdrop-filter:blur(2px) }
.spinner{ width:42px; height:42px; border-radius:999px; border:4px solid rgba(255,255,255,.25); border-top-color:#fff; animation:spin 1s linear infinite }
@keyframes spin{ to{ transform:rotate(360deg) } }
</style>
</head>
<body>
<div id="errbar"></div>
<div id="loader"><div class="spinner"></div></div>

<div class="topbar">
  <div class="topnav">
    <div class="brand">FireOps SIM ‚Äî Advanced Editor</div>
    <div class="spacer"></div>
    <span id="authPill" class="pill">Auth: connecting‚Ä¶</span>
    <button id="toggleTools" class="btn">Hide Tools</button>
  </div>
</div>

<main>
  <div class="app" id="app">
    <!-- LEFT: all tools (collapsible) -->
    <aside class="col" id="tools">
      <details id="drawer" open>
        <summary>Editing Tools (collapse/expand)</summary>
        <div style="margin-top:10px">
          <div class="sectionTitle">Scenario</div>
          <label>Choose scenario</label>
          <select id="scenarioSel"><option value="">Select scenario‚Ä¶</option></select>
          <div class="row" style="margin-top:6px">
            <button class="btn" id="refreshBtn">Refresh</button>
            <button class="btn" id="deleteScenario" style="background:#2a0f14;border-color:#7a2b2b">Delete Scenario</button>
            <span id="statusPill" class="pill">Loading‚Ä¶</span>
            <span id="rootPill" class="pill small">root: ‚Ä¶</span>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Stop meta</div>
          <label>Title</label><input class="input" id="stopTitle" />
          <label>Caption</label><textarea id="stopCaption"></textarea>
          <div class="row">
            <div style="flex:1"><label>Latitude</label><input class="input" id="stopLat" /></div>
            <div style="flex:1"><label>Longitude</label><input class="input" id="stopLng" /></div>
          </div>
          <label>Radius (meters)</label><input class="input" id="stopRadius" value="50" />
          <div class="row" style="margin-top:6px">
            <button class="btn" id="useGPS">Use my location</button>
            <button class="btn" id="saveMeta">Save Meta</button>
          </div>
          <div id="metaMsg" class="pill small" style="margin-top:6px">Ready</div>

          <div class="divider"></div>
          <div class="sectionTitle">Overlays</div>
          <div class="row" style="gap:6px; flex-wrap:nowrap; overflow:auto">
            <button class="btn" data-cat="fire">üî• Fire</button>
            <button class="btn" data-cat="smoke">üå´Ô∏è Smoke</button>
            <button class="btn" data-cat="people">üßç People</button>
            <button class="btn" data-cat="cars">üöó Cars</button>
            <button class="btn" data-cat="hazard">‚ö†Ô∏è Hazard</button>
          </div>
          <div id="overlayShelf" style="margin-top:8px; display:grid; grid-template-columns:repeat(3, 1fr); gap:8px"></div>

          <div class="divider"></div>
          <div class="sectionTitle">Brush / Stamps</div>
          <div class="row">
            <button class="btn" id="brushFire">üî• Fire Brush</button>
            <button class="btn" id="brushSmoke">üå´Ô∏è Smoke Brush</button>
            <button class="btn" id="brushErase">üßΩ Erase Stamps</button>
            <button class="btn" id="brushOff">‚úñ Off</button>
          </div>
          <label>Brush Size <span id="brushSizeReadout" class="pill" style="margin-left:6px">120 px</span></label>
          <input id="brushSize" type="range" min="24" max="320" step="4" value="120" />

          <div class="divider"></div>
          <div class="sectionTitle">Text on Photo</div>
          <div class="row"><button class="btn" id="addTextbox">+ Add Text Box</button></div>
          <label>Selected Text</label><textarea id="tbContent" placeholder="Type notes‚Ä¶"></textarea>
          <label>Font Size</label><input id="tbFont" type="range" min="12" max="72" step="1" value="24" />
          <label>Background Opacity</label><input id="tbBgOpacity" type="range" min="0" max="1" step="0.05" value="0.6" />
          <div class="row" style="margin-top:6px">
            <button class="btn" id="tbApply">Apply</button>
            <button class="btn" id="tbDelete" style="background:#2a0f14;border-color:#7a2b2b">Delete</button>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Selected Overlay</div>
          <div class="row">
            <button class="btn" id="flipSelH">Flip H</button>
            <button class="btn" id="flipSelV">Flip V</button>
            <button class="btn" id="bringFront">Bring Front</button>
            <button class="btn" id="sendBack">Send Back</button>
            <button class="btn" id="deleteObj" style="background:#2a0f14;border-color:#7a2b2b">Delete</button>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Export / Save</div>
          <div class="row">
            <button class="btn" id="exportPNG">Export PNG/JPEG</button>
            <button class="btn" id="saveImage">Save Image to Cloud</button>
          </div>
        </div>
      </details>
    </aside>

    <!-- RIGHT: viewer -->
    <section class="col">
      <div class="sectionTitle">Photos in Scenario (click to load in viewer)</div>
      <div id="thumbRow"></div>

      <div class="row" style="margin:10px 0">
        <button class="btn" id="fit">Fit</button>
        <button class="btn" id="zoomIn">Zoom +</button>
        <button class="btn" id="zoomOut">Zoom ‚àí</button>
        <button class="btn" id="rotateL">Rotate ‚ü≥</button>
        <button class="btn" id="rotateR">Rotate ‚ü≤</button>
        <span class="pill" id="canvasInfo">Canvas</span>
      </div>

      <div class="canvasWrap"><canvas id="c"></canvas></div>
    </section>
  </div>
</main>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js" crossorigin="anonymous"></script>
<script type="module">
/* ---------- helpers ---------- */
const $ = (id)=>document.getElementById(id);
const showErr = (m)=>{ const b=$('errbar'); b.textContent=m; b.style.display='block'; };
const hideErr = ()=>{ $('errbar').style.display='none'; };
const showLoad = (on)=>{ $('loader').style.display = on ? 'grid' : 'none'; };
const status = (msg)=>{ $('statusPill').textContent=msg; };
const setAuthPill = (t)=>{ $('authPill').textContent = `Auth: ${t}`; };

/* collapse tools */
$('toggleTools').onclick = ()=>{
  const app = $('app');
  const collapse = !app.classList.contains('toolsCollapsed');
  app.classList.toggle('toolsCollapsed', collapse);
  $('toggleTools').textContent = collapse ? 'Show Tools' : 'Hide Tools';
  fitCanvas();
};

/* ---------- Firebase ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getDatabase, ref as dbRef, get, set, onValue, remove } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";
import { getStorage, ref as stRef, uploadBytesResumable, uploadBytes, getDownloadURL, getBlob, deleteObject } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-storage.js";
import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence, browserSessionPersistence, inMemoryPersistence } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";

const firebaseConfig = {
  apiKey:"AIzaSyDM6DpRSeZueVKRpbyJyDmhf8WY66KyCDk",
  authDomain:"dailyquiz-d5279.firebaseapp.com",
  databaseURL:"https://dailyquiz-d5279-default-rtdb.firebaseio.com",
  projectId:"dailyquiz-d5279",
  storageBucket:"dailyquiz-d5279.firebasestorage.app",
  appId:"1:94577748034:web:c032d3a1d72db1313de5db",
  measurementId:"G-19DVN7NNH7"
};
const appFB = initializeApp(firebaseConfig);

/* ‚úÖ Force classic bucket to ensure SDK-auth reads/writes work even if public URLs are disabled */
const FORCE_BUCKET = "dailyquiz-d5279.appspot.com";
const storage = getStorage(appFB, `gs://${FORCE_BUCKET}`);

const db = getDatabase(appFB);
const auth = getAuth(appFB);

/* ---------- Auth gate ---------- */
async function ensureAuthed(){
  try{ await setPersistence(auth, browserLocalPersistence); }
  catch{ try{ await setPersistence(auth, browserSessionPersistence); }
  catch{ await setPersistence(auth, inMemoryPersistence); } }

  if (!auth.currentUser){
    await signInAnonymously(auth).catch((e)=>{ setAuthPill('anonymous sign-in failed'); throw e; });
    await new Promise(res=>{
      const unsub = onAuthStateChanged(auth, u=>{ if(u){ unsub(); res(); } });
    });
  }
  const uid = auth.currentUser.uid.slice(0,8);
  setAuthPill(`anon ‚úî (${uid})`);
  return auth.currentUser;
}
async function getIdToken(force=false){
  try{
    const u = auth.currentUser || await ensureAuthed();
    return await u.getIdToken(force);
  }catch{return null;}
}

/* ---------- Root detection (supports /geophoto/scenarios or /scenarios) ---------- */
let ROOT = 'scenarios';
async function detectRoot(){
  const fromQS = new URLSearchParams(location.search).get('root');
  if (fromQS) return fromQS;

  // Prefer geophoto/scenarios if it exists
  try{
    const a = await get(dbRef(db, 'geophoto/scenarios'));
    if (a.exists()) return 'geophoto/scenarios';
  }catch{}
  // Fallback to scenarios
  return 'scenarios';
}
$('rootPill').textContent = 'root: ‚Ä¶';

/* ---------- Storage helpers with auth ---------- */
function toStorageRefString(s){
  if(!s) return s;
  let v = s.trim();
  try{ v = decodeURIComponent(v); }catch{}
  if (v.startsWith('gs://')) return v;

  // https://firebasestorage.googleapis.com/v0/b/<bucket>/o/<path>?...
  let m = v.match(/^https?:\/\/firebasestorage\.googleapis\.com\/v0\/b\/([^/]+)\/o\/([^?]+)/i);
  if (m) return `gs://${m[1]}/${m[2].replace(/\+/g,' ')}`;

  // https://<bucket>.firebasestorage.app/o/<path>?...
  m = v.match(/^https?:\/\/([^/]+)\.firebasestorage\.app\/o\/([^?]+)/i);
  if (m) return `gs://${m[1]}/${m[2].replace(/\+/g,' ')}`;

  // Plain path case
  if (!/^https?:\/\//i.test(v)) return v;
  return v; // unknown URL ‚Äî caller can try fetch() as last resort
}
async function getBlobFromRefString(refStr){
  await ensureAuthed();
  const coerced = toStorageRefString(refStr);
  if (/^https?:\/\//i.test(coerced)){
    // As a last resort, try HTTP fetch (may fail if rules require auth)
    const r = await fetch(coerced, { mode:'cors', credentials:'omit', cache:'no-store' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    return await r.blob();
  }
  const ref = stRef(storage, coerced);
  return await getBlob(ref);
}

/* ---------- Cloud Function (fallback upload) ‚Äî now with ID token ---------- */
const FUNCTION_UPLOAD_URL = 'https://us-central1-dailyquiz-d5279.cloudfunctions.net/uploadScenarioImage';
async function uploadViaFunction(dataURL, scenarioId, fileName){
  const idt = await getIdToken().catch(()=>null);
  const resp = await fetch(FUNCTION_UPLOAD_URL, {
    method:'POST',
    headers:{
      'Content-Type':'application/json',
      ...(idt ? { 'Authorization': `Bearer ${idt}` } : {})
    },
    body: JSON.stringify({ scenarioId, fileName, dataURL })
  });
  if (!resp.ok){
    const txt = await resp.text();
    const e = new Error(`Function HTTP ${resp.status} ${txt}`); e.code='save/function-http'; throw e;
  }
  const json = await resp.json();
  if (!json.ok){
    const e = new Error(`Function error: ${json.error||'unknown'}`); e.code='save/function-error'; throw e;
  }
  return { url: json.url, path: json.path, gsUri: json.gsUri, via:'function' };
}

/* ---------- Canvas ---------- */
const f = new fabric.Canvas('c', { backgroundColor:'#061621', preserveObjectStacking:true });
let baseImage=null;
function fitCanvas(){
  const targetH = Math.max(420, window.innerHeight - 280);
  $('c').style.height = targetH + 'px';
  f.setHeight(targetH);
  const viewer = $('c').closest('.col');
  const w = (viewer?.clientWidth || 900) - 24;
  f.setWidth(w);
  if (baseImage && baseImage.type==='rect'){
    baseImage.set({ left:0, top:0, width:f.getWidth(), height:f.getHeight() });
  }
  f.calcOffset(); f.requestRenderAll();
}
fitCanvas(); addEventListener('resize', fitCanvas);
function blobToObjectURL(blob){ return URL.createObjectURL(blob); }
function revokeURL(u){ try{ URL.revokeObjectURL(u); }catch{} }

/* ---------- Smart path fixer (thumbnail -> original) ---------- */
function candidateOriginals(pathOrUrl){
  const out = new Set();
  if (!pathOrUrl) return [];
  let s = pathOrUrl;
  try{ s = decodeURIComponent(s); }catch{}
  const [base, qs] = s.split('?');
  const variants = new Set([base]);
  variants.add(base.replace(/\/thumbs\//i,'/'));
  variants.add(base.replace(/\/thumb_([^/]+)/i, '/$1'));
  variants.add(base.replace(/([-_])(thumb|small|preview|min|tiny)(\.[a-z0-9]+)$/i, '$3'));
  variants.forEach(v=> variants.add(v.replace(/(\.[a-z0-9]+)\1$/i, '$1')));
  for (const v of variants){
    // also push gs:// variants so SDK can auth
    const gs = toStorageRefString(v);
    out.add(gs);
    if (/^https?:\/\//i.test(s) && qs) out.add(`${v}?${qs}`);
  }
  return Array.from(out).filter(Boolean);
}

/* ---------- Image load pipeline ---------- */
async function loadBlobForStop(stop){
  if (stop.gsUri)        return await getBlobFromRefString(stop.gsUri);
  if (stop.storagePath)  return await getBlobFromRefString(stop.storagePath);
  if (typeof stop.imageURL === 'string' && stop.imageURL){
    // First try through SDK-auth via gs:// conversion
    try{ return await getBlobFromRefString(stop.imageURL); }catch(_e){}
    // Final fallback: direct HTTP (may be blocked by rules)
    const r = await fetch(stop.imageURL, { mode:'cors', credentials:'omit', cache:'no-store' });
    if (!r.ok) throw new Error('HTTP '+r.status);
    return await r.blob();
  }
  if (stop.imageData?.data){
    const fmt = stop.imageData.format==='jpeg' ? 'jpeg' : 'png';
    return await (await fetch(`data:image/${fmt};base64,${stop.imageData.data}`)).blob();
  }
  throw new Error('No image source on this stop.');
}
async function setBaseFromBlob(blob){
  return new Promise((resolve,reject)=>{
    const u = blobToObjectURL(blob);
    fabric.Image.fromURL(u, img=>{
      revokeURL(u);
      if(!img){ reject(new Error('Image decode failed')); return; }
      if (baseImage) f.remove(baseImage);
      baseImage = img; baseImage.selectable=false; baseImage.evented=false; baseImage.set('erasable', false);
      const cw=f.getWidth(), ch=f.getHeight();
      const s=Math.min(cw/img.width, ch/img.height);
      img.scale(s); img.set({ left:(cw-img.width*s)/2, top:(ch-img.height*s)/2 });
      f.add(img); img.moveTo(0); f.requestRenderAll();
      $('canvasInfo').textContent=`Image ${Math.round(img.width)}√ó${Math.round(img.height)} | shown ${Math.round(img.width*s)}√ó${Math.round(img.height*s)}`;
      resolve({ naturalW: img.width, naturalH: img.height });
    }, { crossOrigin:'anonymous' });
  });
}
async function tryUpgradeIfTiny(stop, dims){
  const minGood = 400;
  if ((dims.naturalW >= minGood) || (dims.naturalH >= minGood)) return true;
  const seeds = [stop.storagePath, stop.gsUri, stop.imageURL].filter(Boolean);
  for (const seed of seeds){
    const candidates = candidateOriginals(seed).slice(0, 6);
    for (const cand of candidates){
      try{
        const blob = await getBlobFromRefString(cand);
        const res = await setBaseFromBlob(blob);
        if (res.naturalW >= minGood || res.naturalH >= minGood){
          if (!stop.storagePath && !/^gs:\/\//.test(cand)) stop.storagePath = cand;
          if (!stop.gsUri && /^gs:\/\//.test(cand)) stop.gsUri = cand;
          await persistStopSource(stop);
          return true;
        }
      }catch(_e){}
    }
  }
  return false;
}
async function persistStopSource(stop){
  if (!current || stopIndex<0) return;
  const next = current._stops.slice();
  next[stopIndex] = stop;
  const updated = Object.assign({}, current._raw);
  setStops(updated, next);
  await set(dbRef(db, `${ROOT}/${current.id}`), updated);
  current._raw = updated; current._stops = next;
}

/* ---------- Data ---------- */
let scenarios=[], current=null, stopIndex=-1;

function coerceStops(sc){
  if (Array.isArray(sc?.stops)) return sc.stops;
  if (Array.isArray(sc?.photos)) return sc.photos;
  if (Array.isArray(sc?.images)) return sc.images;
  return [];
}
function setStops(sc, stops){
  if (Array.isArray(sc?.stops)) sc.stops = stops;
  else if (Array.isArray(sc?.photos)) sc.photos = stops;
  else if (Array.isArray(sc?.images)) sc.images = stops;
  else sc.stops = stops;
}
function populateScenarios(){
  const sel=$('scenarioSel'); sel.innerHTML='<option value="">Select scenario‚Ä¶</option>';
  scenarios.forEach(sc=>{
    const o=document.createElement('option');
    o.value=sc.id; o.textContent=(sc.title||'(untitled)') + (sc.active?'':' (inactive)');
    sel.appendChild(o);
  });
}

async function loadScenarios(){
  await ensureAuthed();
  status('Loading‚Ä¶');
  const snap = await get(dbRef(db, ROOT));
  const obj = snap.exists() ? (snap.val()||{}) : {};
  scenarios = Object.entries(obj).map(([id,s])=>({ id, _raw:s, _stops:coerceStops(s), ...s }))
              .sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
  populateScenarios();
  status(`${scenarios.length} scenario(s)`);
}

function subscribeScenarios(){
  const ref = dbRef(db, ROOT);
  onValue(ref, snap=>{
    const v=snap.val()||{};
    scenarios = Object.entries(v).map(([id,s])=>({ id, _raw:s, _stops:coerceStops(s), ...s }))
                .sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
    populateScenarios();
    if (current){
      const fresh=scenarios.find(x=>x.id===current.id);
      if (fresh){ current=fresh; renderThumbs(); }
    }
  }, (err)=>{ showErr('Live updates blocked by rules: '+(err?.message||err)); });
}

/* ---------- Thumbnails row ---------- */
function dataURLFromStored(stored){
  return typeof stored==='string'
    ? stored
    : (stored && stored.data ? `data:image/${stored.format||'jpeg'};base64,${stored.data}` : '');
}
function renderThumbs(){
  const row=$('thumbRow'); row.innerHTML='';
  if (!current || !current._stops?.length){ row.innerHTML='<div class="pill small">No photos/slides</div>'; return; }
  current._stops.forEach((s,i)=>{
    const thumbSrc = s.thumbURL || s.imageURL || dataURLFromStored(s.imageData) || '';
    const img=document.createElement('img'); img.className='thumb'+(i===stopIndex?' active':'');
    img.src=thumbSrc; img.alt=s.title||('Stop '+(i+1));
    img.onerror=()=>{ img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120"><rect width="100%" height="100%" fill="#000"/><text x="50%" y="52%" fill="#fff" font-size="14" text-anchor="middle">No image</text></svg>`); };
    img.onclick=()=>loadStop(i);
    row.appendChild(img);
  });
}

/* ---------- Scenario selection ---------- */
$('scenarioSel').onchange = async ()=>{
  const id=$('scenarioSel').value;
  current=scenarios.find(s=>s.id===id)||null;
  stopIndex=-1;
  renderThumbs();
  f.clear(); baseImage=null; fitCanvas();
  if (current && current._stops.length){ await loadStop(0); } // auto open first
};

/* ---------- Load a stop ---------- */
async function loadStop(i){
  hideErr();
  if (!current) return;
  const s=current._stops[i]; if(!s) return;
  stopIndex=i;
  Array.from($('thumbRow').children).forEach((n,idx)=> n.classList.toggle('active', idx===i));

  $('stopTitle').value = s.title||'';
  $('stopCaption').value = s.caption||'';
  $('stopLat').value = s.lat??'';
  $('stopLng').value = s.lng??'';
  $('stopRadius').value = (s.radiusMeters ?? s.radius ?? 50);

  f.clear(); baseImage=null;
  if (s.type==='text'){
    setBaseAsTextSlide(s.text||'', s.fontSize||34);
    return;
  }

  try{
    showLoad(true);
    await ensureAuthed();
    const blob = await loadBlobForStop(s);
    const dims = await setBaseFromBlob(blob);
    const ok = await tryUpgradeIfTiny(s, dims);
    if (!ok && (dims.naturalW < 400 || dims.naturalH < 400)){
      showErr('Loaded a small thumbnail. A higher-resolution original could not be found.');
    }
  }catch(e){
    showErr('Image load failed (rules?): '+(e.message||e));
  }finally{
    showLoad(false);
  }

  // overlays
  if (Array.isArray(s.overlays)){
    for (const ov of s.overlays){
      if (ov?.kind==='text'){
        const tb = new fabric.Textbox(ov.text||'', {
          left:ov.left||100, top:ov.top||100, scaleX:ov.scaleX||1, scaleY:ov.scaleY||1,
          angle:ov.angle||0, opacity:ov.opacity??1, fontSize:ov.fontSize||24, fill:ov.fill||'#fff',
          backgroundColor:ov.backgroundColor||'rgba(0,0,0,0.6)', padding:ov.padding??8,
          cornerStyle:'circle', transparentCorners:false, editable:true
        }); tb._kind='text'; f.add(tb);
      } else if (ov?.src){
        await new Promise(res=>{
          fabric.Image.fromURL(ov.src, img=>{
            img.set({ left:ov.left||0, top:ov.top||0, scaleX:ov.scaleX||1, scaleY:ov.scaleY||1,
                      angle:ov.angle||0, opacity:ov.opacity??1, flipX:!!ov.flipX, flipY:!!ov.flipY,
                      erasable:true, cornerStyle:'circle', transparentCorners:false });
            f.add(img); res();
          }, { crossOrigin:'anonymous' });
        });
      }
    }
    f.requestRenderAll();
  }
}

/* ---------- Base makers ---------- */
function setBaseAsTextSlide(text, fontSize){
  f.clear();
  const rect = new fabric.Rect({ left:0, top:0, width:f.getWidth(), height:f.getHeight(), fill:'#000', selectable:false, evented:false, erasable:false });
  baseImage = rect;
  const tb = new fabric.Textbox(text||'', {
    width: Math.floor(f.getWidth()*0.8),
    left: Math.floor(f.getWidth()*0.1),
    top:  Math.floor(f.getHeight()*0.2),
    fontSize: fontSize||34, fill:'#fff', textAlign:'center',
    fontFamily:'system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif',
    selectable:false, evented:false, erasable:false
  });
  tb.isBaseText=true;
  f.add(rect); f.add(tb); rect.moveTo(0); f.requestRenderAll();
  $('canvasInfo').textContent='Text slide';
}

/* ---------- Meta save ---------- */
function serializeOverlays(){
  const out=[];
  f.getObjects().forEach(o=>{
    if (o===baseImage || o.isBaseText) return;
    if (o.type==='image'){
      out.push({
        kind:'image',
        src:o.getSrc ? o.getSrc() : (o._originalElement?.src || o.src || ''),
        left:o.left||0, top:o.top||0, scaleX:o.scaleX||1, scaleY:o.scaleY||1,
        angle:o.angle||0, opacity:o.opacity??1, flipX:!!o.flipX, flipY:!!o.flipY
      });
    } else if (o.type==='textbox'){
      out.push({
        kind:'text', text:o.text||'', left:o.left||0, top:o.top||0, scaleX:o.scaleX||1, scaleY:o.scaleY||1,
        angle:o.angle||0, opacity:o.opacity??1, fontSize:o.fontSize||24, fill:o.fill||'#fff',
        backgroundColor:o.backgroundColor||'rgba(0,0,0,0.6)', padding:o.padding??8
      });
    }
  });
  return out;
}
$('useGPS').onclick = ()=>{
  navigator.geolocation.getCurrentPosition(p=>{
    $('stopLat').value = p.coords.latitude.toFixed(6);
    $('stopLng').value = p.coords.longitude.toFixed(6);
    $('metaMsg').textContent='GPS captured.';
  }, e=>{ $('metaMsg').textContent='GPS error: '+e.message; }, { enableHighAccuracy:true, timeout:10000 });
};
$('saveMeta').onclick = async ()=>{
  try{
    await ensureAuthed();
    if(!current || stopIndex<0) throw new Error('Select a stop first.');
    const s = Object.assign({}, current._stops[stopIndex]);
    s.title = $('stopTitle').value.trim();
    s.caption = $('stopCaption').value.trim();
    const lat = $('stopLat').value.trim()==='' ? null : parseFloat($('stopLat').value);
    const lng = $('stopLng').value.trim()==='' ? null : parseFloat($('stopLng').value);
    s.lat = lat; s.lng = lng;
    s.radiusMeters = Math.max(5, Math.min(1000, Math.round(parseInt($('stopRadius').value||'50',10))));
    s.overlays = serializeOverlays();

    const next=current._stops.slice(); next[stopIndex]=s;
    const updated=Object.assign({}, current._raw); setStops(updated,next);
    await set(dbRef(db, `${ROOT}/${current.id}`), updated);
    current._raw = updated; current._stops = next;
    renderThumbs();
    $('metaMsg').textContent='Meta saved.';
  }catch(e){ $('metaMsg').textContent=String(e.message||e); }
};

/* ---------- Export / Save (Storage ‚Üí Function ‚Üí Inline) ---------- */
const EDIT_MAX_EDGE     = 1600;
const EDIT_THUMB_EDGE   = 480;
const EDIT_JPEG_QUALITY = 0.85;

async function dataURLFromCanvasScaled(fabricCanvas, maxEdge=EDIT_MAX_EDGE, quality=EDIT_JPEG_QUALITY){
  const raw = fabricCanvas.toDataURL({ format:'jpeg', quality:1 });
  const img = new Image(); img.decoding = 'async'; img.src = raw; await img.decode();
  const w = img.naturalWidth, h = img.naturalHeight;
  const s = Math.min(1, maxEdge / Math.max(w, h));
  const outW = Math.round(w*s), outH = Math.round(h*s);
  const c = document.createElement('canvas'); c.width = outW; c.height = outH;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(img, 0, 0, outW, outH);
  return c.toDataURL('image/jpeg', quality);
}
async function thumbFromDataURL(dataURL, maxEdge=EDIT_THUMB_EDGE, q=0.8){
  const img = new Image(); img.decoding='async'; img.src=dataURL; await img.decode();
  const w = img.naturalWidth, h = img.naturalHeight;
  const s = Math.min(1, maxEdge / Math.max(w, h));
  const outW = Math.round(w*s), outH = Math.round(h*s);
  const c = document.createElement('canvas'); c.width=outW; c.height=outH;
  const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
  ctx.drawImage(img, 0, 0, outW, outH);
  return c.toDataURL('image/jpeg', q);
}

function dataURLtoBlob(dataURL){
  const [head,b64] = dataURL.split(',');
  const mime = (/data:(.*?);base64/.exec(head)||[, 'application/octet-stream'])[1];
  const bin = atob(b64), len = bin.length, buf = new Uint8Array(len);
  for (let i=0;i<len;i++) buf[i] = bin.charCodeAt(i);
  return new Blob([buf], { type:mime });
}
async function uploadWithTimeout(ref, blob, metadata, onProgress){
  return new Promise((resolve,reject)=>{
    const task = uploadBytesResumable(ref, blob, metadata);
    const killer = setTimeout(()=>{ try{ task.cancel(); }catch{}; reject(Object.assign(new Error('Timed out while uploading'), { code:'save/timeout-upload' })); }, 45000);
    task.on('state_changed',
      s=>{ /* optional progress */ },
      e=>{ clearTimeout(killer); reject(e); },
      ()=>{ clearTimeout(killer); resolve(); }
    );
  });
}

$('exportPNG').onclick = async ()=>{
  const url = await dataURLFromCanvasScaled(f, EDIT_MAX_EDGE, 0.95);
  const a=document.createElement('a'); a.href=url; a.download='image-edited.jpg'; a.click();
};

$('saveImage').onclick = async ()=>{
  try{
    if(!current || stopIndex<0) throw new Error('Select a stop first.');
    showLoad(true);
    await ensureAuthed();

    // Render dataURLs
    const dataURL      = await dataURLFromCanvasScaled(f, EDIT_MAX_EDGE, EDIT_JPEG_QUALITY);
    const thumbDataURL = await thumbFromDataURL(dataURL, EDIT_THUMB_EDGE, 0.8);

    // Convert to blobs for resumable upload
    const fullBlob  = dataURLtoBlob(dataURL);
    const thumbBlob = dataURLtoBlob(thumbDataURL);

    const ts = Date.now();
    const base = `scenarios/${current.id}/${ts}_edited_${stopIndex}`;
    const fullRef  = stRef(storage, `${base}.jpg`);
    const thumbRef = stRef(storage, `scenarios/${current.id}/thumbs/${ts}_edited_${stopIndex}.jpg`);
    const metaFull = { contentType:'image/jpeg', cacheControl:'public,max-age=31536000,immutable' };
    const metaThmb = { contentType:'image/jpeg', cacheControl:'public,max-age=31536000,immutable' };

    let cloud=null;
    // Try direct Storage first (auth via SDK)
    try{
      await uploadWithTimeout(fullRef, fullBlob, metaFull);
      try{ await uploadBytes(thumbRef, thumbBlob, metaThmb); }catch(e){ /* thumb failure is non-fatal */ }
      const fullURL  = await getDownloadURL(fullRef);
      const thumbURL = await getDownloadURL(thumbRef).catch(()=>fullURL);
      cloud = { url:fullURL, thumbURL, path:fullRef.fullPath, gsUri:`gs://${FORCE_BUCKET}/${fullRef.fullPath}`, via:'storage' };
    }catch(e1){
      // Fallback to Cloud Function (sends ID token)
      try{
        const res = await uploadViaFunction(dataURL, current.id, `${ts}_edited_${stopIndex}.jpg`);
        cloud = { url:res.url, thumbURL:res.url, path:res.path, gsUri:res.gsUri, via:'function' };
      }catch(e2){
        // Final fallback: inline base64 in DB (do not lose the edit)
        cloud = null;
      }
    }

    // Update stop
    const s = Object.assign({}, current._stops[stopIndex]);
    s.overlays = serializeOverlays();
    if (cloud){
      s.imageURL    = cloud.url;
      s.thumbURL    = cloud.thumbURL || cloud.url;
      s.storagePath = cloud.path;
      s.gsUri       = cloud.gsUri;
      s.imageData   = null;
    }else{
      s.imageData   = { format:'jpeg', data:dataURL.split(',')[1] };
    }

    const next=current._stops.slice(); next[stopIndex]=s;
    const updated=Object.assign({}, current._raw); setStops(updated,next);
    await set(dbRef(db, `${ROOT}/${current.id}`), updated);

    current._raw=updated; current._stops=next;
    renderThumbs();
    $('metaMsg').textContent = cloud ? 'Compressed image saved to Cloud.' : 'Saved inline (backup).';
  }catch(e){
    $('metaMsg').textContent='Save failed (rules?): '+(e.message||e);
  }finally{
    showLoad(false);
  }
};

/* ---------- Delete scenario (best-effort Storage cleanup) ---------- */
$('deleteScenario').onclick = async ()=>{
  try{
    if (!current) { alert('Select a scenario first.'); return; }
    const sure = confirm(`Delete scenario "${current.title||current.id}" and its photos? This cannot be undone.`);
    if (!sure) return;
    showLoad(true);
    await ensureAuthed();

    // Collect storage refs from stops
    const paths = new Set();
    (current._stops||[]).forEach(s=>{
      if (s.storagePath) paths.add(s.storagePath);
      if (s.thumbPath)   paths.add(s.thumbPath);
      if (s.gsUri)       paths.add(s.gsUri);
    });

    // Best-effort delete each
    for (const p of paths){
      try{ await deleteObject(stRef(storage, toStorageRefString(p))); }catch(_e){ /* ignore */ }
    }

    // Remove DB node
    await remove(dbRef(db, `${ROOT}/${current.id}`));

    // Reset UI
    current=null; stopIndex=-1; populateScenarios(); $('scenarioSel').value=''; $('thumbRow').innerHTML='';
    f.clear(); baseImage=null; fitCanvas();
    status('Scenario deleted.');
  }catch(e){
    showErr('Delete failed (rules?): '+(e.message||e));
  }finally{
    showLoad(false);
  }
};

/* ---------- Canvas utilities ---------- */
$('fit').onclick  = ()=>{
  if (baseImage && baseImage.type==='image'){
    const cw=f.getWidth(), ch=f.getHeight(), s=Math.min(cw/baseImage.width, ch/baseImage.height);
    baseImage.scale(s); baseImage.set({ left:(cw-baseImage.width*s)/2, top:(ch-baseImage.height*s)/2 });
    f.requestRenderAll();
  } else if (baseImage && baseImage.type==='rect'){
    const t=f.getObjects('textbox').find(o=>o.isBaseText);
    setBaseAsTextSlide(t?t.text:'', t?t.fontSize:34);
  }
};
$('zoomIn').onclick = ()=> f.setZoom(f.getZoom()*1.1);
$('zoomOut').onclick= ()=> f.setZoom(f.getZoom()/1.1);
$('rotateL').onclick = ()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)+90); f.requestRenderAll(); } };
$('rotateR').onclick = ()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)-90); f.requestRenderAll(); } };

/* ---------- Text tools ---------- */
function selTB(){ const o=f.getActiveObject(); return (o && o.type==='textbox' && !o.isBaseText) ? o : null; }
$('addTextbox').onclick = ()=>{
  const tb = new fabric.Textbox('Double-click to edit', {
    left: Math.max(10, (f.getWidth()*0.5)-120),
    top:  Math.max(10, (f.getHeight()*0.5)-30),
    width: 260, fontSize: 24, fill:'#fff', backgroundColor:'rgba(0,0,0,0.6)', padding:8,
    cornerStyle:'circle', transparentCorners:false, editable:true
  });
  f.add(tb); f.setActiveObject(tb); $('tbContent').value=tb.text;
};
$('tbApply').onclick = ()=>{
  const tb=selTB(); if(!tb){ alert('Select a text box first.'); return; }
  tb.set({ text:$('tbContent').value, fontSize:parseInt($('tbFont').value,10)||24, backgroundColor:`rgba(0,0,0,${parseFloat($('tbBgOpacity').value)||0.6})` });
  f.requestRenderAll();
};
$('tbDelete').onclick = ()=>{ const tb=selTB(); if(tb){ f.remove(tb); f.discardActiveObject(); f.requestRenderAll(); } };

/* ---------- Overlays + brush ---------- */
const OVERLAY_BASE='https://fireopssim.com/geophoto/overlays/';
const FOLDER={ fire:'fire', smoke:'smoke', people:'people', cars:'cars', hazard:'hazard' };
const EXT=['png','webp','jpg','jpeg'];
async function listOverlays(cat){
  try{
    const r = await fetch(`${OVERLAY_BASE}manifest.json`, { cache:'no-store' });
    if (r.ok){ const j = await r.json(); if (Array.isArray(j[FOLDER[cat]])) return j[FOLDER[cat]]; }
  }catch{}
  const prefix = {fire:'fire', smoke:'smoke', people:'person', cars:'car', hazard:'hazard'}[cat]||'img';
  const found=[]; let miss=0;
  for(let i=1;i<=60 && miss<5;i++){
    let hit=false;
    for(const ext of EXT){
      const url = `${OVERLAY_BASE}${FOLDER[cat]}/${prefix}${i}.${ext}`;
      try{ const h=await fetch(url,{method:'HEAD',cache:'no-store'}); if(h.ok){ found.push(`${prefix}${i}.${ext}`); hit=true; break; } }catch{}
    }
    miss = hit ? 0 : miss+1;
  }
  return found;
}
function renderShelf(cat){
  const shelf=$('overlayShelf'); shelf.innerHTML='';
  listOverlays(cat).then(files=>{
    if(!files.length){ shelf.innerHTML='<div class="pill small">No overlays found</div>'; return; }
    files.forEach(name=>{
      const url=`${OVERLAY_BASE}${FOLDER[cat]}/${name}`;
      const cell=document.createElement('div'); cell.style.border='1px solid rgba(255,255,255,.14)'; cell.style.borderRadius='10px'; cell.style.padding='4px'; cell.style.background='#0b2130';
      const img=new Image(); img.src=url; img.alt=name; img.style.width='100%'; img.style.display='block';
      img.onclick=()=> addOverlay(url);
      cell.appendChild(img); shelf.appendChild(cell);
    });
  });
}
function addOverlay(src){
  fabric.Image.fromURL(src, img=>{
    const cw=f.getWidth(), ch=f.getHeight(), targetW=cw*0.28, scale=targetW/img.width;
    img.scale(scale);
    img.set({ left:cw/2-(img.width*img.scaleX)/2, top:ch/2-(img.height*img.scaleY)/2,
              cornerStyle:'circle', transparentCorners:false, shadow:'rgba(0,0,0,0.35) 0 6px 16px', erasable:true });
    f.add(img); f.setActiveObject(img); f.requestRenderAll();
  }, { crossOrigin:'anonymous' });
}
Array.from(document.querySelectorAll('#tools [data-cat]')).forEach(b=>{
  b.addEventListener('click', ()=> renderShelf(b.dataset.cat));
});
renderShelf('fire');

let brushMode='off', pointerDown=false, lastStamp=null;
const brushSize=$('brushSize'), brushSizeReadout=$('brushSizeReadout');
brushSize.oninput=()=> brushSizeReadout.textContent=(parseInt(brushSize.value,10)||120)+' px';
$('brushFire').onclick = ()=> brushMode='fire';
$('brushSmoke').onclick= ()=> brushMode='smoke';
$('brushErase').onclick= ()=> brushMode='erase';
$('brushOff').onclick  = ()=> brushMode='off';
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
async function randomOverlay(cat){
  const files = await listOverlays(cat); if(!files.length) return null;
  const i=Math.floor(Math.random()*files.length);
  return `${OVERLAY_BASE}${FOLDER[cat]}/${files[i]}`;
}
async function stampAt(p, cat){
  const file = await randomOverlay(cat); if(!file) return;
  const R = (parseInt(brushSize.value,10)||120)/2;
  if (lastStamp && dist(p,lastStamp) < R*0.6) return; lastStamp=p;
  fabric.Image.fromURL(file, img=>{
    const baseW=img.width||200, scale=(R*2)/baseW, j=0.75+Math.random()*0.5;
    img.scale(scale*j);
    img.set({ left:p.x-(img.width*img.scaleX)/2, top:p.y-(img.height*img.scaleY)/2, angle:(Math.random()*30-15),
              opacity:0.9, cornerStyle:'circle', transparentCorners:false, erasable:true, selectable:false, evented:false });
    f.add(img); f.requestRenderAll();
  }, { crossOrigin:'anonymous' });
}
function eraseStampsAt(p){
  const R=(parseInt(brushSize.value,10)||120)/2;
  const targets = f.getObjects('image').filter(o => o!==baseImage);
  for (const obj of targets){
    const cx=obj.left + (obj.width*obj.scaleX)/2, cy=obj.top + (obj.height*obj.scaleY)/2;
    if (Math.hypot(cx-p.x, cy-p.y) <= R) f.remove(obj);
  }
  f.requestRenderAll();
}
f.on('mouse:down', (e)=>{ pointerDown=true; const p=f.getPointer(e.e); if(brushMode==='fire') stampAt(p,'fire'); else if(brushMode==='smoke') stampAt(p,'smoke'); else if(brushMode==='erase') eraseStampsAt(p); });
f.on('mouse:move', (e)=>{ if(!pointerDown) return; const p=f.getPointer(e.e); if(brushMode==='fire') stampAt(p,'fire'); else if(brushMode==='smoke') stampAt(p,'smoke'); else if(brushMode==='erase') eraseStampsAt(p); });
f.on('mouse:up', ()=>{ pointerDown=false; });

/* order / delete selected overlay */
$('bringFront').onclick = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.bringToFront(); f.requestRenderAll(); } };
$('sendBack').onclick  = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.sendToBack(); if(baseImage) baseImage.sendToBack(); f.requestRenderAll(); } };
$('deleteObj').onclick = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ f.remove(o); f.discardActiveObject(); f.requestRenderAll(); } };
$('flipSelH').onclick  = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.set('flipX', !o.flipX); f.requestRenderAll(); } };
$('flipSelV').onclick  = ()=>{ const o=f.getActiveObject(); if(o && o!==baseImage){ o.set('flipY', !o.flipY); f.requestRenderAll(); } };

/* ---------- Boot: auth ‚Üí root ‚Üí data ---------- */
(async ()=>{
  try{
    await ensureAuthed();
    ROOT = await detectRoot();
    $('rootPill').textContent = `root: ${ROOT}`;
    await loadScenarios();
    subscribeScenarios();
  }catch(e){
    showErr('Startup failed: '+(e.message||e));
  }
})();
</script>
</body>
</html>

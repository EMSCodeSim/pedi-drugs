<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FireOps SIM — Advanced Editor</title<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FireOps SIM — Advanced Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="Advanced editor for FireOps SIM Geo-Photo scenarios with overlays and RTDB/Cloud Storage save." />
  <meta name="theme-color" content="#0b0f14" />
  <link rel="icon" href="data:," />
  <style>
    :root{ --bg:#0b0f14; --bg2:#101726; --card:#121823; --muted:#8ea0b3; --text:#eaf2ff; --blue:#0a84ff; --teal:#2dd4bf; --red:#ff3b30; --shadow:0 12px 34px rgba(0,0,0,.38); --radius:18px; --radiusSm:14px; --border: rgba(255,255,255,.08);}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:
      radial-gradient(1400px 700px at 15% -15%, rgba(10,132,255,.28), transparent 60%),
      radial-gradient(1200px 600px at 110% 0%, rgba(255,59,48,.22), transparent 60%),
      linear-gradient(165deg, var(--bg2), var(--bg) 55%)}
    a{color:inherit;text-decoration:none}

    .topbar{position:sticky;top:0;z-index:50;background:rgba(12,15,22,.78);backdrop-filter:blur(6px) saturate(120%);border-bottom:1px solid rgba(255,255,255,.07)}
    .topnav{max-width:1200px;margin:0 auto;padding:10px 20px;display:flex;align-items:center;gap:14px;flex-wrap:wrap}
    .brandmini{display:flex;align-items:center;gap:12px;font-weight:800}
    .logo img{width:40px;height:40px;border-radius:10px;box-shadow:var(--shadow);object-fit:cover;background:#0f1624}
    .tag{color:var(--muted);font-size:12px}

    main{max-width:1200px;margin:20px auto 80px;padding:0 20px}
    .app{display:grid;grid-template-columns:320px 1fr 420px;gap:12px;align-items:start}
    .col{background:var(--card);border:1px solid var(--border);border-radius:var(--radiusSm);box-shadow:var(--shadow);padding:12px;overflow:auto}
    label{display:block;margin:8px 0 6px 2px;font-size:12px;color:var(--muted)}
    select,input,textarea,button{font-size:14px}
    select,input[type="text"],textarea{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#0d2430;color:var(--text);outline:none}
    textarea{min-height:72px;resize:vertical}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 12px;background:linear-gradient(180deg,#54a6ff,var(--blue));color:#03131b;font-weight:800;cursor:pointer;box-shadow:var(--shadow)}
    .btn.secondary{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,.18)}
    .btn.warn{background:#ffc857;color:#2a1d00}
    .btn.danger{background:var(--red);color:#ffecec}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sectionTitle{font-weight:800;margin:6px 0}
    .thumb{width:56px;height:56px;border-radius:8px;object-fit:cover;border:1px solid rgba(255,255,255,.15);cursor:pointer;background:#0b2130}
    .thumb.active{outline:3px solid var(--teal)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);color:var(--muted)}

    .canvasWrap{position:relative;background:#061621;border:1px solid rgba(255,255,255,.12);border-radius:12px;overflow:hidden}
    #c{display:block;width:100%;height:calc(100vh - 360px);background:transparent}
    .bar{display:flex;gap:8px;flex-wrap:wrap}
    .divider{height:1px;background:rgba(255,255,255,.1);opacity:.8;margin:10px 0}

    /* Overlay shelf */
    .olThumb{width:100%;aspect-ratio:1/1;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#0b2130;display:flex;align-items:center;justify-content:center;cursor:pointer}
    .olThumb img{max-width:88%;max-height:88%;display:block}
    .ol-tab.active{outline:3px solid var(--teal)}

    /* HUDs */
    #errbar{position:fixed;left:10px;bottom:10px;background:#2b0d0d;color:#ffd7d7;border:1px solid #7a2b2b;border-radius:12px;padding:8px 12px;max-width:80vw;display:none;z-index:9999}
    .overlayHUD{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:9998}
    .hudCard{min-width:220px;padding:18px;border-radius:14px;background:#0c1220;border:1px solid rgba(255,255,255,.12);box-shadow:var(--shadow);display:flex;gap:12px;align-items:center;justify-content:center;font-weight:800}
    .spinner{width:22px;height:22px;border-radius:50%;border:3px solid rgba(255,255,255,.25);border-top-color:#fff;animation:spin 0.9s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    footer{max-width:1200px;margin:40px auto;padding:18px 20px;color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,.06);display:flex;justify-content:space-between;gap:16px;flex-wrap:wrap}
    @media (max-width:1220px){ .app{grid-template-columns:1fr} #c{height:56vh} }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topnav">
      <div class="brandmini">
        <div class="logo" aria-hidden="true"><img src="/assets/logo/fire-ops-sim.png" alt="FireOps SIM logo" /></div>
        <div>
          <div style="line-height:1.1; font-size:15px; font-weight:900">FireOps SIM</div>
          <div class="tag">Real-Time Fire Scene Simulator</div>
        </div>
      </div>
    </div>
  </div>

  <main>
    <div id="errbar"></div>

    <!-- Loading & Saving HUDs -->
    <div id="loadingHUD" class="overlayHUD" aria-hidden="true">
      <div class="hudCard"><div class="spinner"></div><div id="loadingLabel">Loading…</div></div>
    </div>
    <div id="savingHUD" class="overlayHUD" aria-hidden="true">
      <div class="hudCard"><div class="spinner"></div><div>Saving…</div></div>
    </div>

    <div id="app" class="app">
      <!-- Left: scenario + meta -->
      <div class="col" id="leftCol">
        <div class="row" style="justify-content:space-between">
          <div class="pill" id="statusPill">Loading…</div>
          <button id="refresh" class="btn secondary">Refresh</button>
        </div>

        <label>Scenario</label>
        <select id="scenarioSel"><option value="">Select scenario…</option></select>

        <!-- Scenario-level dispatch editor -->
        <div class="divider"></div>
        <div class="sectionTitle">Scenario Dispatch</div>
        <label>Dispatch Text</label>
        <textarea id="scenarioDispatch" placeholder="Ex: Engine 1 dispatched to a residential structure fire..."></textarea>
        <div class="row">
          <label class="pill" for="scenarioDispatchTTS" style="cursor:pointer">Read via TTS</label>
          <input id="scenarioDispatchTTS" type="checkbox" />
          <button id="saveScenarioMeta" class="btn">Save Scenario</button>
        </div>
        <div id="scenarioMetaMsg" class="pill" style="margin-top:6px">Ready</div>

        <div class="divider"></div>
        <div class="row" style="justify-content:space-between">
          <div class="sectionTitle">Photos / Slides in scenario</div>
          <button id="addTextSlide" class="btn secondary">+ Add Text Slide</button>
        </div>
        <div id="stopList" class="row"></div>

        <div class="divider"></div>
        <div class="sectionTitle">Selected stop meta</div>
        <label>Title</label><input id="stopTitle" type="text" />
        <label>Caption</label><textarea id="stopCaption"></textarea>

        <!-- Text Slide panel (conditional) -->
        <div id="textSlidePanel" style="display:none">
          <div class="sectionTitle">Text Slide</div>
          <label>Text Content</label>
          <textarea id="textSlideContent" placeholder="Type the slide text here…"></textarea>
          <div class="row">
            <div class="pill"><input id="textSlideManual" type="checkbox" /> <span>Manual mode (ignore GPS)</span></div>
            <div class="pill"><input id="textSlideTTS" type="checkbox" checked /> <span>TTS for this slide</span></div>
          </div>
          <label>Font Size</label>
          <input id="textSlideFontSize" type="range" min="18" max="72" step="2" value="34" />
          <div class="row" style="margin-top:6px">
            <button id="renderTextPreview" class="btn secondary">Render Preview</button>
          </div>
          <div id="textSlideMsg" class="pill" style="margin-top:6px">Text slide ready</div>
          <div class="divider"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Latitude</label><input id="stopLat" type="text" /></div>
          <div style="flex:1"><label>Longitude</label><input id="stopLng" type="text" /></div>
        </div>
        <label>Radius (meters)</label><input id="stopRadius" type="text" placeholder="50" />
        <div class="row" style="margin-top:6px">
          <button id="useGPS" class="btn secondary">Use my location</button>
          <button id="saveMeta" class="btn">Save Meta</button>
        </div>
        <div id="metaMsg" class="pill" style="margin-top:6px">Ready</div>

        <div class="divider"></div>
        <div class="row" id="replaceRow">
          <input id="replaceFile" type="file" accept="image/*" />
          <button id="replaceApply" class="btn">Replace Image (local preview)</button>
        </div>
        <div class="row" style="margin-top:6px">
          <button id="deleteStop" class="btn danger">Delete This Photo/Slide</button>
          <button id="exportPNG" class="btn secondary">Export PNG</button>
        </div>
      </div>

      <!-- Center: canvas -->
      <div class="col">
        <div class="bar" style="margin-bottom:8px">
          <button id="fit" class="btn secondary">Fit</button>
          <button id="zoomIn" class="btn secondary">Zoom +</button>
          <button id="zoomOut" class="btn secondary">Zoom −</button>
          <button id="rotateL" class="btn secondary">Rotate ⟲</button>
          <button id="rotateR" class="btn secondary">Rotate ⟳</button>
          <span class="pill" id="canvasInfo">Canvas</span>
          <button id="saveImage" class="btn">Save Image to Cloud</button>
        </div>
        <div class="canvasWrap"><canvas id="c"></canvas></div>
      </div>

      <!-- Right: overlays + brush + text + eraser + flip -->
      <div class="col" id="rightCol">
        <div class="sectionTitle">Overlays</div>
        <div class="row" style="gap:6px; flex-wrap:nowrap; overflow:auto">
          <button class="btn secondary ol-tab" data-cat="fire">🔥 Fire</button>
          <button class="btn secondary ol-tab" data-cat="smoke">🌫️ Smoke</button>
          <button class="btn secondary ol-tab" data-cat="people">🧍 People</button>
          <button class="btn secondary ol-tab" data-cat="cars">🚗 Cars</button>
          <button class="btn secondary ol-tab" data-cat="hazard">⚠️ Hazard</button>
        </div>
        <div id="overlayShelf" style="margin-top:8px; display:grid; grid-template-columns:repeat(3, 1fr); gap:8px"></div>

        <label style="margin-top:10px">Hue (selected overlay image)</label>
        <input id="overlayHue" type="range" min="-180" max="180" step="1" value="0" />

        <label style="margin-top:10px">Opacity (selected overlay)</label>
        <input id="overlayOpacity" type="range" min="0.05" max="1" step="0.05" value="1" />

        <div class="row" style="margin-top:8px">
          <button id="bringFront" class="btn secondary">Bring to Front</button>
          <button id="sendBack" class="btn secondary">Send to Back</button>
          <button id="deleteObj" class="btn danger">Delete Selected</button>
        </div>

        <div class="divider"></div>
        <div class="sectionTitle">Brush / Stamps</div>
        <div class="row">
          <button id="brushFire" class="btn secondary">🔥 Fire Brush</button>
          <button id="brushSmoke" class="btn secondary">🌫️ Smoke Brush</button>
          <button id="brushErase" class="btn secondary">🧽 Erase Stamps</button>
          <button id="brushOff" class="btn secondary">✖ Off</button>
        </div>
        <label style="margin-top:8px">Brush Size <span id="brushSizeReadout" class="pill" style="margin-left:6px">120 px</span></label>
        <input id="brushSize" type="range" min="24" max="320" step="4" value="120" />

        <div class="divider"></div>
        <div class="sectionTitle">Text Boxes</div>
        <div class="row">
          <button id="addTextbox" class="btn secondary">+ Add Text Box</button>
        </div>
        <label>Selected Text</label>
        <textarea id="tbContent" placeholder="Type information (patient vitals, notes, etc.)…"></textarea>
        <label>Font Size</label>
        <input id="tbFont" type="range" min="12" max="72" step="1" value="24" />
        <label>Background Opacity</label>
        <input id="tbBgOpacity" type="range" min="0" max="1" step="0.05" value="0.6" />
        <div class="row" style="margin-top:6px">
          <button id="tbApply" class="btn">Apply to Selected</button>
          <button id="tbDelete" class="btn danger">Delete Text Box</button>
        </div>

        <div class="divider"></div>
        <div class="sectionTitle">Eraser (selected overlay)</div>
        <div class="row">
          <button id="eraserStart" class="btn warn">Start</button>
          <button id="eraserDone" class="btn">Finish</button>
          <button id="eraserCancel" class="btn secondary">Cancel</button>
        </div>
        <label style="margin-top:8px">Brush Size (overlay eraser)</label>
        <input id="eraserSize" type="range" min="5" max="120" step="1" value="30" />
        <label style="margin-top:8px">Overlay Opacity</label>
        <input id="eraserOverlayOpacity" type="range" min="0.05" max="1" step="0.05" value="1" />
        <div class="row" style="margin-top:8px">
          <button id="eraserUndo" class="btn secondary">Undo Erase</button>
          <button id="eraserRedo" class="btn secondary">Redo Erase</button>
          <button id="eraserClear" class="btn secondary">Clear Erase</button>
        </div>
        <div class="pill" id="eraserStatus" style="margin-top:6px">Eraser: off</div>

        <div class="divider"></div>
        <div class="sectionTitle">Transform Overlay</div>
        <div class="row">
          <button id="flipSelH" class="btn secondary">Flip H</button>
          <button id="flipSelV" class="btn secondary">Flip V</button>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <div>© <span id="year"></span> FireOps SIM</div>
    <div class="external">Part of the <a href="https://emscodesim.com" rel="noopener">EMS Code Sim</a> training ecosystem</div>
  </footer>

  <!-- Fabric 5.x -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script type="module">
  /* Error banner */
  const ERR = (msg) => { const b=document.getElementById('errbar'); b.textContent=msg; b.style.display='block'; };

  (async () => {
    document.getElementById('year').textContent = new Date().getFullYear();

    const loadingHUD = document.getElementById('loadingHUD');
    const loadingLabel = document.getElementById('loadingLabel');
    const savingHUD  = document.getElementById('savingHUD');
    const showLoading = (t='Loading…')=>{ loadingLabel.textContent=t; loadingHUD.style.display='flex'; };
    const hideLoading = ()=>{ loadingHUD.style.display='none'; };
    const showSaving  = ()=>{ savingHUD.style.display='flex'; };
    const hideSaving  = ()=>{ savingHUD.style.display='none'; };

    /* Firebase (add Storage) */
    const [{ initializeApp }] = await Promise.all([ import("https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js") ]);
    const [{ getDatabase, ref, onValue, get, set }] = await Promise.all([ import("https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js") ]);
    const [{ getStorage, ref:stRef, uploadString, getDownloadURL }] = await Promise.all([ import("https://www.gstatic.com/firebasejs/10.12.4/firebase-storage.js") ]);

    const firebaseConfig = {
      apiKey:"AIzaSyDM6DpRSeZueVKRpbyJyDmhf8WY66KyCDk",
      authDomain:"dailyquiz-d5279.firebaseapp.com",
      databaseURL:"https://dailyquiz-d5279-default-rtdb.firebaseio.com",
      projectId:"dailyquiz-d5279",
      storageBucket:"dailyquiz-d5279.appspot.com",
      appId:"1:94577748034:web:c032d3a1d72db1313de5db",
      measurementId:"G-19DVN7NNH7"
    };
    const appFB = initializeApp(firebaseConfig);
    const db = getDatabase(appFB);
    const storage = getStorage(appFB);
    const BUCKET = appFB.options?.storageBucket || (firebaseConfig.projectId + ".appspot.com");

    /* DOM Refs */
    const statusPill=document.getElementById('statusPill');
    const scenarioSel=document.getElementById('scenarioSel');
    const stopList=document.getElementById('stopList');
    const refreshBtn=document.getElementById('refresh');

    const scenarioDispatch=document.getElementById('scenarioDispatch');
    const scenarioDispatchTTS=document.getElementById('scenarioDispatchTTS');
    const saveScenarioMeta=document.getElementById('saveScenarioMeta');
    const scenarioMetaMsg=document.getElementById('scenarioMetaMsg');
    const addTextSlide=document.getElementById('addTextSlide');

    const stopTitle=document.getElementById('stopTitle');
    const stopCaption=document.getElementById('stopCaption');

    const textSlidePanel=document.getElementById('textSlidePanel');
    const textSlideContent=document.getElementById('textSlideContent');
    const textSlideManual=document.getElementById('textSlideManual');
    const textSlideTTS=document.getElementById('textSlideTTS');
    const textSlideFontSize=document.getElementById('textSlideFontSize');
    const renderTextPreview=document.getElementById('renderTextPreview');
    const textSlideMsg=document.getElementById('textSlideMsg');

    const stopLat=document.getElementById('stopLat');
    const stopLng=document.getElementById('stopLng');
    const stopRadius=document.getElementById('stopRadius');
    const useGPS=document.getElementById('useGPS');
    const saveMeta=document.getElementById('saveMeta');
    const metaMsg=document.getElementById('metaMsg');

    const replaceRow=document.getElementById('replaceRow');
    const replaceFile=document.getElementById('replaceFile');
    theReplaceApply=document.getElementById('replaceApply');
    const deleteStop=document.getElementById('deleteStop');
    const exportPNG=document.getElementById('exportPNG');

    const cInfo=document.getElementById('canvasInfo');
    const fitBtn=document.getElementById('fit');
    const zoomIn=document.getElementById('zoomIn');
    const zoomOut=document.getElementById('zoomOut');
    const rotateL=document.getElementById('rotateL');
    const rotateR=document.getElementById('rotateR');
    const saveImage=document.getElementById('saveImage');

    const overlayShelf=document.getElementById('overlayShelf');
    const tabBtns = Array.from(document.querySelectorAll('.ol-tab'));
    const overlayHue=document.getElementById('overlayHue');
    const overlayOpacity=document.getElementById('overlayOpacity');
    const bringFront=document.getElementById('bringFront');
    const sendBack=document.getElementById('sendBack');
    const deleteObj=document.getElementById('deleteObj');

    const eraserStart=document.getElementById('eraserStart');
    const eraserDone=document.getElementById('eraserDone');
    const eraserCancel=document.getElementById('eraserCancel');
    const eraserSize=document.getElementById('eraserSize');
    const eraserOverlayOpacity=document.getElementById('eraserOverlayOpacity');
    const eraserUndo=document.getElementById('eraserUndo');
    const eraserRedo=document.getElementById('eraserRedo');
    const eraserClear=document.getElementById('eraserClear');
    const eraserStatus=document.getElementById('eraserStatus');
    const flipSelH=document.getElementById('flipSelH');
    const flipSelV=document.getElementById('flipSelV');

    /* Brush & TextBox controls */
    const brushFire=document.getElementById('brushFire');
    const brushSmoke=document.getElementById('brushSmoke');
    const brushErase=document.getElementById('brushErase');
    const brushOff=document.getElementById('brushOff');
    const brushSize=document.getElementById('brushSize');
    const brushSizeReadout=document.getElementById('brushSizeReadout');

    const addTextbox=document.getElementById('addTextbox');
    const tbContent=document.getElementById('tbContent');
    const tbFont=document.getElementById('tbFont');
    const tbBgOpacity=document.getElementById('tbBgOpacity');
    const tbApply=document.getElementById('tbApply');
    const tbDelete=document.getElementById('tbDelete');

    /* Canvas */
    const fabricCanvas = new fabric.Canvas('c', { backgroundColor:'#061621', preserveObjectStacking:true, selection:true });
    let baseImage=null; // fabric.Image or fabric.Rect for text slides

    /* Brush state */
    let brushMode = 'off'; // 'fire' | 'smoke' | 'erase' | 'off'
    let pointerDown = false;
    let lastStamp = null; // {x,y}
    let brushCursor = null;
    const STAMP_GROUP = 'stampLayer'; // tag for brush stamps

    function ensureBrushCursor(){
      const r = (parseInt(brushSize.value,10)||120)/2;
      if (!brushCursor){
        brushCursor = new fabric.Circle({
          left:-1000, top:-1000, radius:r,
          fill:'rgba(255,255,255,0.08)',
          stroke:'rgba(255,255,255,0.85)',
          strokeWidth:1.5,
          selectable:false, evented:false, excludeFromExport:true,
          hoverCursor:'none'
        });
        const inner = new fabric.Circle({
          radius: Math.max(1, r-2), left:-1000, top:-1000,
          fill:'transparent', stroke:'rgba(0,0,0,0.6)', strokeWidth:1,
          selectable:false, evented:false, excludeFromExport:true
        });
        inner._isInnerRing = true;
        brushCursor._inner = inner;
        fabricCanvas.add(brushCursor);
        fabricCanvas.add(inner);
        brushCursor.moveTo(99999);
        inner.moveTo(99999);
      }
      brushCursor.set({ radius:r });
      if (brushCursor._inner){ brushCursor._inner.set({ radius:Math.max(1,r-2) }); }
      fabricCanvas.requestRenderAll();
    }
    function showBrushCursor(show){
      if (!brushCursor) ensureBrushCursor();
      const out = show ? 1 : 0;
      brushCursor.set({ opacity: out });
      if (brushCursor._inner) brushCursor._inner.set({ opacity: out });
    }
    function moveBrushCursor(p){
      if (!brushCursor) return;
      brushCursor.set({ left:p.x - brushCursor.radius, top:p.y - brushCursor.radius });
      if (brushCursor._inner) brushCursor._inner.set({ left: p.x - brushCursor._inner.radius, top: p.y - brushCursor._inner.radius });
    }

    function setBrushMode(mode){
      brushMode = mode;
      [brushFire,brushSmoke,brushErase,brushOff].forEach(b=>b.classList.remove('active'));
      const map = { fire:brushFire, smoke:brushSmoke, erase:brushErase, off:brushOff };
      (map[mode]||brushOff).classList.add('active');
      const brushing = (mode!=='off');
      fabricCanvas.skipTargetFind = brushing;
      fabricCanvas.selection = !brushing;
      showBrushCursor(brushing);
      lastStamp = null;
      stopErasing();
    }

    brushSize.oninput = ()=>{
      brushSizeReadout.textContent = (parseInt(brushSize.value,10)||120) + ' px';
      ensureBrushCursor();
    };

    /* Fit / Resize */
    function fitCanvas(){
      const reserved = 260;
      const targetH = Math.max(380, window.innerHeight - reserved);
      document.getElementById('c').style.height = targetH + 'px';
      fabricCanvas.setHeight(targetH);
      const midCol = document.querySelector('main .col:nth-child(2)');
      const width = (midCol?.clientWidth || 800) - 24;
      fabricCanvas.setWidth(width);
      if (baseImage && baseImage.type === 'rect') {
        baseImage.set({ left:0, top:0, width:fabricCanvas.getWidth(), height:fabricCanvas.getHeight() });
        const baseText = fabricCanvas.getObjects('textbox').find(o => o.isBaseText);
        if (baseText){
          baseText.set({
            width: Math.floor(fabricCanvas.getWidth()*0.8),
            left: Math.floor(fabricCanvas.getWidth()*0.1),
            top:  Math.floor(fabricCanvas.getHeight()*0.2)
          });
        }
      }
      ensureBrushCursor();
      fabricCanvas.calcOffset();
      fabricCanvas.requestRenderAll();
    }
    fitCanvas(); window.addEventListener('resize', fitCanvas);

    function setBaseImageFromURL(url){
      return new Promise((resolve,reject)=>{
        fabric.Image.fromURL(url, (img)=>{
          if (!img) { reject(new Error('Image load failed')); return; }
          if (baseImage) fabricCanvas.remove(baseImage);
          baseImage = img; baseImage.selectable=false; baseImage.evented=false; baseImage.set('erasable', false);
          const cw=fabricCanvas.getWidth(), ch=fabricCanvas.getHeight();
          const scale=Math.min(cw/img.width, ch/img.height);
          baseImage.scale(scale);
          baseImage.set({ left:(cw - img.width*scale)/2, top:(ch - img.height*scale)/2, crossOrigin:'anonymous' });
          fabricCanvas.add(baseImage); baseImage.moveTo(0); fabricCanvas.requestRenderAll();
          cInfo.textContent=`Image ${Math.round(img.width)}×${Math.round(img.height)} (scale ${scale.toFixed(2)})`;
          resolve();
        }, { crossOrigin:'anonymous' });
      });
    }
    function setBaseImageFromDataURL(dataURL){
      return setBaseImageFromURL(dataURL);
    }

    // Render a text slide
    function setBaseAsTextSlide(text, fontSize=34){
      fabricCanvas.clear();
      const rect = new fabric.Rect({
        left:0, top:0, width:fabricCanvas.getWidth(), height:fabricCanvas.getHeight(),
        fill:'#000', selectable:false, evented:false, erasable:false
      });
      baseImage = rect;
      const tb = new fabric.Textbox(text||'', {
        width: Math.floor(fabricCanvas.getWidth()*0.8),
        left: Math.floor(fabricCanvas.getWidth()*0.1),
        top:  Math.floor(fabricCanvas.getHeight()*0.2),
        fontSize: fontSize||34,
        fill:'#fff', textAlign:'center',
        fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif',
        selectable:false, evented:false, erasable:false
      });
      tb.isBaseText = true;
      fabricCanvas.add(rect); fabricCanvas.add(tb);
      rect.moveTo(0);
      fabricCanvas.requestRenderAll();
      cInfo.textContent='Text slide';
    }

    /* === SMART EXPORT (we'll upload this to Storage) === */
    function encodeCanvas() {
      const MAX_BYTES = 9_000_000;
      const zoom = fabricCanvas.getZoom() || 1;
      let multiplier = 1;
      if (baseImage) {
        const s = baseImage.scaleX || 1;
        multiplier = (1 / s) * (1 / zoom);
      }
      multiplier = Math.max(1, Math.min(8, multiplier));

      const bytesOf = (b64) => Math.floor((b64.length * 3) / 4);

      let url = fabricCanvas.toDataURL({ format:'png', quality:1, multiplier });
      let b64 = url.split(',')[1] || '';
      if (bytesOf(b64) <= MAX_BYTES) return { format:'png', data:b64 };

      const qSteps = [0.95, 0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6];
      for (const q of qSteps) {
        url = fabricCanvas.toDataURL({ format:'jpeg', quality:q, multiplier });
        b64 = url.split(',')[1] || '';
        if (bytesOf(b64) <= MAX_BYTES) return { format:'jpeg', data:b64 };
      }
      let m = multiplier;
      while (m > 0.7) {
        m *= 0.85;
        for (const q of qSteps) {
          url = fabricCanvas.toDataURL({ format:'jpeg', quality:q, multiplier:m });
          b64 = url.split(',')[1] || '';
          if (bytesOf(b64) <= MAX_BYTES) return { format:'jpeg', data:b64 };
        }
      }
      url = fabricCanvas.toDataURL({ format:'jpeg', quality:0.5, multiplier:Math.max(0.6, m) });
      b64 = url.split(',')[1] || '';
      return { format:'jpeg', data:b64 };
    }

    function toDataURLFromStored(storedOrUrl) {
      if (typeof storedOrUrl === 'string') return storedOrUrl; // HTTPS Storage URL or data URL
      if (!storedOrUrl || !storedOrUrl.data) return '';
      const fmt = storedOrUrl.format === 'jpeg' ? 'jpeg' : 'png';
      return `data:image/${fmt};base64,${storedOrUrl.data}`;
    }

    exportPNG.onclick = () => {
      const enc = encodeCanvas();
      const url = `data:image/${enc.format};base64,${enc.data}`;
      const a = document.createElement('a');
      a.href = url;
      a.download = 'image-edited.' + (enc.format === 'jpeg' ? 'jpg' : 'png');
      a.click();
    };

    /* Scenarios */
    function coerceStops(sc){
      if (Array.isArray(sc?.stops))  return sc.stops;
      if (Array.isArray(sc?.photos)) return sc.photos;
      if (Array.isArray(sc?.images)) return sc.images;
      return [];
    }
    function setStops(sc, stops){
      if (Array.isArray(sc?.stops)) sc.stops = stops;
      else if (Array.isArray(sc?.photos)) sc.photos = stops;
      else if (Array.isArray(sc?.images)) sc.images = stops;
      else sc.stops = stops;
    }

    let scenarios=[], current=null, stopIndex=-1;
    const ROOT='scenarios';

    function showStatus(msg){ statusPill.textContent = msg; }
    function populateList(){
      scenarioSel.innerHTML = '<option value="">Select scenario…</option>';
      scenarios.forEach(sc => {
        const o=document.createElement('option'); o.value=sc.id; o.textContent=(sc.title||'(untitled)') + (sc.active? '':' (inactive)');
        scenarioSel.appendChild(o);
      });
    }

    function textThumbDataURL(text){
      const t = (text || 'TEXT').split('\n')[0].slice(0,18);
      const svg = `
        <svg xmlns='http://www.w3.org/2000/svg' width='80' height='80'>
          <rect width='100%' height='100%' fill='#000'/>
          <rect x='6' y='6' width='68' height='20' rx='6' fill='#0a84ff'/>
          <text x='40' y='21' fill='#001' font-size='12' text-anchor='middle' font-weight='700'>TEXT</text>
          <text x='40' y='50' fill='#fff' font-size='10' text-anchor='middle'>${t.replace(/&/g,'&amp;')}</text>
        </svg>`;
      return "data:image/svg+xml;utf8," + encodeURIComponent(svg);
    }

    function renderStopsThumbs(){
      stopList.innerHTML='';
      if(!current || !current._stops?.length){ stopList.innerHTML='<div class="pill">No photos/slides</div>'; return; }
      current._stops.forEach((s,idx)=>{
        const img=document.createElement('img');
        img.className='thumb'+(idx===stopIndex?' active':'');
        const isText = s?.type === 'text';
        const src = isText
          ? textThumbDataURL(s.text||s.title||'')
          : toDataURLFromStored(s.imageURL || s.imageData);
        img.src=src||textThumbDataURL(s?.title||'');
        img.title=(s.title||`Stop ${idx+1}`) + (isText?' (Text slide)':'');
        img.onerror=()=>{ img.src=textThumbDataURL(s?.title||''); };
        img.onclick=()=>loadStop(idx);
        stopList.appendChild(img);
      });
    }

    async function loadScenarios(){
      try{
        showLoading('Loading scenarios…');
        const snap = await get(ref(db, ROOT));
        const obj = snap.exists() ? (snap.val()||{}) : {};
        scenarios = Object.entries(obj).map(([id, s])=>({
          id, _raw:s, _stops:coerceStops(s), ...s
        })).sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
        populateList();
        showStatus(`${scenarios.length} scenario(s) loaded`);
      }catch(e){
        showStatus('Error: ' + (e?.message || e));
        ERR(e?.message || e);
      } finally { hideLoading(); }
    }

    function startLive(){
      onValue(ref(db, ROOT), snap=>{
        const v=snap.val()||{};
        scenarios = Object.entries(v).map(([id,s])=>({
          id, _raw:s, _stops:coerceStops(s), ...s
        })).sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
        populateList();
        if (current){
          const fresh = scenarios.find(sc=>sc.id===current.id);
          if (fresh){ current=fresh; renderStopsThumbs(); }
        }
        showStatus(`${scenarios.length} scenario(s) loaded`);
      }, err=> showStatus('RTDB onValue error: '+(err?.message||err)));
    }

    await loadScenarios();
    startLive();
    refreshBtn.onclick = loadScenarios;

    function applyScenarioMetaToUI(){
      if (!current){ scenarioDispatch.value=''; scenarioDispatchTTS.checked=false; return; }
      const raw = current._raw || {};
      scenarioDispatch.value = raw.dispatchText || '';
      scenarioDispatchTTS.checked = !!raw.dispatchTTS;
    }

    scenarioSel.onchange = async ()=>{
      const id=scenarioSel.value;
      current = scenarios.find(s=>s.id===id) || null;
      stopIndex=-1;
      renderStopsThumbs();
      applyScenarioMetaToUI();
      fabricCanvas.clear(); baseImage=null;
      fitCanvas();
    };

    // Save scenario-level meta (dispatch text + TTS)
    saveScenarioMeta.onclick = async () => {
      try{
        if (!current) throw new Error('Select a scenario first.');
        showSaving();
        const updated = { ...current._raw, dispatchText: scenarioDispatch.value.trim(), dispatchTTS: !!scenarioDispatchTTS.checked };
        await set(ref(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated;
        scenarioMetaMsg.textContent = 'Scenario saved.';
      }catch(e){
        scenarioMetaMsg.textContent = 'Error: ' + (e?.message||e);
      }finally{ hideSaving(); }
    };

    // Create & add a new text slide
    addTextSlide.onclick = async ()=>{
      try{
        if (!current) throw new Error('Select a scenario first.');
        showSaving();
        const nextStops = [ ...current._stops ];
        const newStop = {
          type:'text',
          title:'Text Slide',
          caption:'',
          text:'New slide text',
          fontSize:34,
          manual:true,
          tts:true,
          lat:null, lng:null,
          radiusMeters:50,
          overlays:[]
        };
        nextStops.push(newStop);
        const updated = { ...current._raw };
        setStops(updated, nextStops);
        await set(ref(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated; current._stops = nextStops;
        renderStopsThumbs();
        stopIndex = nextStops.length - 1;
        await loadStop(stopIndex);
        scenarioMetaMsg.textContent = 'Text slide added.';
      }catch(e){
        scenarioMetaMsg.textContent = 'Error: ' + (e?.message||e);
      }finally{ hideSaving(); }
    };

    function isTextStop(s){ return s && s.type === 'text'; }

    function updateStopMetaPanelUI(s){
      const textMode = isTextStop(s);
      textSlidePanel.style.display = textMode ? '' : 'none';
      replaceRow.style.display = textMode ? 'none' : '';
    }

    async function loadStop(idx){
      if(!current) return;
      const s=current._stops[idx]; if(!s) return;
      stopIndex=idx;

      // Common meta
      stopTitle.value=s.title||'';
      stopCaption.value=s.caption||'';
      stopLat.value=(s.lat ?? '').toString();
      stopLng.value=(s.lng ?? '').toString();
      stopRadius.value=(s.radiusMeters ?? s.radius ?? 50).toString();

      // Text slide meta
      textSlideContent.value = isTextStop(s) ? (s.text||'') : '';
      textSlideFontSize.value = isTextStop(s) ? (s.fontSize||34) : 34;
      textSlideManual.checked = !!s.manual;
      textSlideTTS.checked = !!s.tts;

      Array.from(stopList.children).forEach((n,i)=>n.classList.toggle('active', i===idx));
      fabricCanvas.clear(); baseImage=null;

      updateStopMetaPanelUI(s);

      // Prefer Cloud Storage URL; fall back to RTDB imageData
      const src = toDataURLFromStored(s.imageURL || s.imageData);

      if (isTextStop(s)){
        setBaseAsTextSlide(s.text||'', s.fontSize||34);
      } else {
        if(!src){ metaMsg.textContent='No image in this stop.'; return; }
        showLoading('Loading photo…');
        await setBaseImageFromURL(src);
      }

      // Rehydrate overlays
      if (Array.isArray(s.overlays)) {
        for (const ov of s.overlays){
          if (ov?.kind === 'text'){
            const tb = new fabric.Textbox(ov.text||'', {
              left: ov.left||100, top: ov.top||100,
              scaleX: ov.scaleX||1, scaleY: ov.scaleY||1,
              angle: ov.angle||0, opacity: ov.opacity??1,
              fontSize: ov.fontSize||24,
              fill: ov.fill||'#fff',
              backgroundColor: ov.backgroundColor || 'rgba(0,0,0,0.6)',
              padding: ov.padding ?? 8,
              cornerStyle:'circle', transparentCorners:false,
              editable:true
            });
            tb._kind='text';
            fabricCanvas.add(tb);
            continue;
          }
          if (!ov?.src) continue;
          await new Promise(res=>{
            fabric.Image.fromURL(ov.src, img=>{
              try{
                img.set({
                  left:ov.left||0, top:ov.top||0,
                  scaleX:ov.scaleX||1, scaleY:ov.scaleY||1,
                  angle:ov.angle||0, opacity:ov.opacity??1,
                  flipX:!!ov.flipX, flipY:!!ov.flipY,
                  erasable:true, cornerStyle:'circle', transparentCorners:false
                });
                if (Array.isArray(ov.erase) && ov.erase.length){
                  const circles = ov.erase.map(e => new fabric.Circle({
                    left: e.x, top: e.y, radius: e.r,
                    originX:'center', originY:'center', absolutePositioned:true
                  }));
                  img.set('clipPath', new fabric.Group(circles, { absolutePositioned:true, inverted:true }));
                }
                img._eraseUndoStack = []; img._eraseRedoStack = [];
                if (ov.stampTag) img.stampTag = ov.stampTag;
                fabricCanvas.add(img);
              } finally { res(); }
            }, { crossOrigin:'anonymous' });
          });
        }
        fabricCanvas.requestRenderAll();
      }
      hideLoading();
    }

    /* GPS + Meta save */
    useGPS.onclick=()=>{ navigator.geolocation.getCurrentPosition(p=>{ stopLat.value=p.coords.latitude.toFixed(6); stopLng.value=p.coords.longitude.toFixed(6); metaMsg.textContent='GPS captured.'; }, e=>{ metaMsg.textContent='GPS error: '+e.message; }, { enableHighAccuracy:true, timeout:10000 }); };

    function serializeOverlays(){
      const out=[];
      fabricCanvas.getObjects().forEach(obj=>{
        if (obj===baseImage) return;
        if (obj.isBaseText) return;
        if (obj.type === 'image'){
          let erase = null;
          if (obj.clipPath && obj.clipPath.type === 'group' && obj.clipPath.inverted) {
            erase = (obj.clipPath._objects || []).map(o => ({
              type: o.type, x: o.left, y: o.top, r: o.radius || 0,
            }));
          }
          out.push({
            kind:'image',
            src: obj.getSrc ? obj.getSrc() : obj._originalElement?.src || obj.src || '',
            left: obj.left||0, top: obj.top||0,
            scaleX: obj.scaleX||1, scaleY: obj.scaleY||1,
            angle: obj.angle||0, opacity: obj.opacity??1,
            flipX: !!obj.flipX,  flipY: !!obj.flipY,
            erase,
            stampTag: obj.stampTag || null
          });
        } else if (obj.type === 'textbox'){
          out.push({
            kind:'text',
            text: obj.text || '',
            left: obj.left||0, top: obj.top||0,
            scaleX: obj.scaleX||1, scaleY: obj.scaleY||1,
            angle: obj.angle||0, opacity: obj.opacity??1,
            fontSize: obj.fontSize||24,
            fill: obj.fill||'#fff',
            backgroundColor: obj.backgroundColor || 'rgba(0,0,0,0.6)',
            padding: obj.padding ?? 8
          });
        }
      });
      return out;
    }

    saveMeta.onclick=async()=>{ try{
      if(!current || stopIndex<0) throw new Error('Select a stop first.');
      showSaving();
      const isText = isTextStop(current._stops[stopIndex]);
      const s = { ...current._stops[stopIndex] };
      s.title=stopTitle.value.trim();
      s.caption=stopCaption.value.trim();

      if (isText){
        s.type='text';
        s.text = textSlideContent.value;
        s.fontSize = parseInt(textSlideFontSize.value,10) || 34;
        s.tts = !!textSlideTTS.checked;
        s.manual = !!textSlideManual.checked;
      }

      s.lat = (stopLat.value.trim()==='' ? null : parseFloat(stopLat.value));
      s.lng = (stopLng.value.trim()==='' ? null : parseFloat(stopLng.value));
      s.radiusMeters=Math.max(5, Math.min(1000, Math.round(parseInt(stopRadius.value||'50',10))));
      if( (s.lat!==null && Number.isNaN(s.lat)) || (s.lng!==null && Number.isNaN(s.lng)) ) throw new Error('Invalid GPS coordinates.');

      s.overlays = serializeOverlays();

      const nextStops = [ ...current._stops ]; nextStops[stopIndex] = s;
      const updated = { ...current._raw };
      setStops(updated, nextStops);
      await set(ref(db, `${ROOT}/${current.id}`), updated);
      current._raw = updated; current._stops = nextStops;
      renderStopsThumbs();

      if (isText) setBaseAsTextSlide(s.text, s.fontSize);

      metaMsg.textContent='Meta saved.';
    }catch(err){ metaMsg.textContent=String(err.message||err); }
     finally { hideSaving(); } };

    function readFileAsDataURL(f){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f); }); }
    theReplaceApply.onclick=async()=>{ const f=replaceFile.files?.[0]; if(!f){ metaMsg.textContent='Choose a file first.'; return; } const data=await readFileAsDataURL(f); await setBaseImageFromDataURL(data); };

    async function uploadEditedToStorage(dataURL, scenarioId, idx){
      const ts = Date.now();
      const path = `scenarios/${scenarioId}/${ts}_edited_${idx}.jpg`;
      const refObj = stRef(storage, path);
      await uploadString(refObj, dataURL, 'data_url');
      const url = await getDownloadURL(refObj);
      const gsUri = `gs://${BUCKET}/${path}`;
      return { url, path, gsUri };
    }

    async function persistCurrentStopImageAndOverlays(){
      if(!current || stopIndex<0) throw new Error('Select a stop first.');
      showSaving();
      try{
        // Export canvas, upload to Cloud Storage, then save download URL
        const enc = encodeCanvas(); // { format, data }
        const dataURL = `data:image/${enc.format};base64,${enc.data}`;
        const { url, path, gsUri } = await uploadEditedToStorage(dataURL, current.id, stopIndex);

        const s = { ...current._stops[stopIndex] };
        s.imageURL  = url;
        s.storagePath = path;
        s.gsUri = gsUri;
        s.imageData = null;      // drop old inline payload
        s.overlays  = serializeOverlays();

        const nextStops = [ ...current._stops ]; nextStops[stopIndex] = s;
        const updated = { ...current._raw };
        setStops(updated, nextStops);
        await set(ref(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated; current._stops = nextStops;
        renderStopsThumbs();
        metaMsg.textContent='Image saved to Cloud & linked.';
      } finally { hideSaving(); }
    }
    saveImage.onclick=()=>persistCurrentStopImageAndOverlays().catch(e=> metaMsg.textContent=String(e.message||e));

    // Re-render text preview without saving
    renderTextPreview.onclick = ()=>{
      const txt = textSlideContent.value;
      const fs = parseInt(textSlideFontSize.value,10) || 34;
      setBaseAsTextSlide(txt, fs);
      textSlideMsg.textContent = 'Preview updated (not yet saved).';
    };

    /* Overlay shelf — dynamic, no hardcoding */
    const OVERLAY_BASE = 'https://fireopssim.com/geophoto/overlays/';
    const FOLDER_MAP = { cars:'cars', people:'people', fire:'fire', smoke:'smoke', hazard:'hazard' };
    const CAT_PREFIX = { fire:'fire', smoke:'smoke', people:'person', cars:'car', hazard:'hazard' };
    const EXTENSIONS = ['png','webp','jpg','jpeg'];
    const OVERLAY_CACHE = Object.create(null);

    function resolveFolder(cat){ return (FOLDER_MAP[cat] || cat); }
    function resolveSpritePath(cat, name){ return `${OVERLAY_BASE}${resolveFolder(cat)}/${name}`; }

    async function listFromManifest(baseUrl, folder){
      const candidates = [`${baseUrl}index.json`, `${baseUrl}_index.json`];
      for (const url of candidates){
        try{
          const r = await fetch(url, { cache:'no-store' });
          if (r.ok && (r.headers.get('content-type')||'').includes('application/json')){
            const j = await r.json();
            if (Array.isArray(j)) return j;
            if (Array.isArray(j.files)) return j.files;
            if (j[folder] && Array.isArray(j[folder])) return j[folder];
          }
        }catch{}
      }
      try{
        const root = `${OVERLAY_BASE}manifest.json`;
        const r = await fetch(root, { cache:'no-store' });
        if (r.ok && (r.headers.get('content-type')||'').includes('application/json')){
          const j = await r.json();
          if (j && Array.isArray(j[folder])) return j[folder];
        }
      }catch{}
      return null;
    }

    async function listFromAutoIndex(baseUrl){
      try{
        const r = await fetch(baseUrl, { cache:'no-store' });
        const ctype = r.headers.get('content-type') || '';
        if (r.ok && ctype.includes('text/html')){
          const html = await r.text();
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const hrefs = Array.from(doc.querySelectorAll('a[href]')).map(a => a.getAttribute('href') || '');
          const files = hrefs.map(h => h.replace(/^\.\//, '')).filter(h => /\.(png|webp|jpe?g)$/i.test(h));
          return files.length ? files : null;
        }
      }catch{}
      return null;
    }

    async function listFromProbing(baseUrl, cat){
      const prefix = CAT_PREFIX[cat] || 'img';
      const found = [];
      let misses = 0;
      const MAX_MISS_STREAK = 6, MAX_STEPS = 80;
      for (let i=1; i<=MAX_STEPS && misses<MAX_MISS_STREAK; i++){
        let hit = false;
        for (const ext of EXTENSIONS){
          const url = `${baseUrl}${prefix}${i}.${ext}`;
          try{
            const r = await fetch(url, { method:'HEAD', cache:'no-store' });
            if (r.ok){ found.push(`${prefix}${i}.${ext}`); hit = true; break; }
          }catch{}
        }
        misses = hit ? 0 : misses + 1;
      }
      return found.length ? found : null;
    }

    async function listOverlays(cat){
      if (OVERLAY_CACHE[cat]) return OVERLAY_CACHE[cat];
      const folder = resolveFolder(cat);
      const baseUrl = `${OVERLAY_BASE}${folder}/`;

      let files = await listFromManifest(baseUrl, folder);
      if (files && files.length){
        files = files.filter(f => /\.(png|webp|jpe?g)$/i.test(f));
        OVERLAY_CACHE[cat] = files; return files;
      }

      files = await listFromAutoIndex(baseUrl);
      if (files && files.length){ OVERLAY_CACHE[cat] = files; return files; }

      files = await listFromProbing(baseUrl, cat);
      if (files && files.length){ OVERLAY_CACHE[cat] = files; return files; }

      OVERLAY_CACHE[cat] = [];
      return [];
    }

    async function renderShelf(cat){
      overlayShelf.innerHTML = '';
      overlayShelf.setAttribute('aria-busy','true');
      try{
        const files = await listOverlays(cat);
        if (!files.length){
          const msg = document.createElement('div');
          msg.className = 'pill';
          msg.textContent = 'No overlays found in /overlays/' + resolveFolder(cat);
          overlayShelf.appendChild(msg);
          return;
        }
        for (const name of files){
          const div = document.createElement('div');
          div.className = 'olThumb';
          const img = document.createElement('img');
          img.src = resolveSpritePath(cat, name);
          img.alt = `${cat}-${name}`;
          img.onerror = () => { div.style.opacity = .5; div.title = 'Missing: ' + img.src; };
          div.appendChild(img);
          div.onclick = () => addOverlayImage(resolveSpritePath(cat, name));
          overlayShelf.appendChild(div);
        }
      } finally {
        overlayShelf.removeAttribute('aria-busy');
      }
    }

    tabBtns.forEach(btn => {
      btn.onclick = () => {
        tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        renderShelf(btn.dataset.cat);
      };
    });
    if (tabBtns[0]) { tabBtns[0].classList.add('active'); renderShelf(tabBtns[0].dataset.cat); }

    function addOverlayImage(src){
      fabric.Image.fromURL(
        src,
        img => {
          const cw=fabricCanvas.getWidth(), ch=fabricCanvas.getHeight();
          const targetW=cw*0.28;
          const scale=targetW/img.width;
          img.scale(scale);
          img.set({
            left:cw/2-(img.width*img.scaleX)/2,
            top:ch/2-(img.height*img.scaleY)/2,
            cornerStyle:'circle',
            transparentCorners:false,
            shadow:'rgba(0,0,0,0.35) 0 6px 16px',
            erasable:true
          });
          img._eraseUndoStack=[];
          img._eraseRedoStack=[];
          fabricCanvas.add(img);
          fabricCanvas.setActiveObject(img);
          fabricCanvas.requestRenderAll();
        },
        { crossOrigin:'anonymous' }
      );
    }

    /* Hue/Opacity/Order */
    const supportsHue = !!(fabric.Image && fabric.Image.filters && fabric.Image.filters.HueRotation);
    overlayHue.disabled = !supportsHue;
    function ensureHueFilter(img){ img.filters = img.filters || []; img.filters = img.filters.filter(f => !(f && f.type === 'HueRotation')); }
    overlayHue.oninput = (e)=>{ if(!supportsHue) return; const o=fabricCanvas.getActiveObject(); if(o && o.type==='image' && o!==baseImage){ const deg=parseInt(e.target.value,10)||0; ensureHueFilter(o); if (deg !== 0) o.filters.push(new fabric.Image.filters.HueRotation({ rotation: deg * Math.PI/180 })); o.applyFilters(); fabricCanvas.requestRenderAll(); } };
    overlayOpacity.oninput = (e)=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ o.set('opacity', parseFloat(e.target.value)); fabricCanvas.requestRenderAll(); } };

    bringFront.onclick = ()=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ o.bringToFront(); fabricCanvas.requestRenderAll(); } };
    sendBack.onclick  = ()=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ o.sendToBack(); if(baseImage) baseImage.sendToBack(); fabricCanvas.requestRenderAll(); } };
    deleteObj.onclick = ()=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ fabricCanvas.remove(o); fabricCanvas.discardActiveObject(); fabricCanvas.requestRenderAll(); } };

    /* ===== Text Boxes on Photos ===== */
    function selectedTextbox(){
      const o=fabricCanvas.getActiveObject();
      return (o && o.type==='textbox' && !o.isBaseText) ? o : null;
    }

    addTextbox.onclick = ()=>{
      const tb = new fabric.Textbox('Double-click to edit', {
        left: Math.max(10, (fabricCanvas.getWidth()*0.5)-120),
        top:  Math.max(10, (fabricCanvas.getHeight()*0.5)-30),
        width: 240,
        fontSize: parseInt(tbFont.value,10)||24,
        fill:'#fff',
        backgroundColor: `rgba(0,0,0,${parseFloat(tbBgOpacity.value)||0.6})`,
        padding: 8,
        cornerStyle:'circle',
        transparentCorners:false,
        editable:true
      });
      tb._kind='text';
      fabricCanvas.add(tb);
      fabricCanvas.setActiveObject(tb);
      tbContent.value = tb.text;
      fabricCanvas.requestRenderAll();
    };

    tbApply.onclick = ()=>{
      const tb = selectedTextbox(); if(!tb){ alert('Select a text box first.'); return; }
      tb.set({
        text: tbContent.value,
        fontSize: parseInt(tbFont.value,10)||24,
        backgroundColor: `rgba(0,0,0,${parseFloat(tbBgOpacity.value)||0.6})`
      });
      fabricCanvas.requestRenderAll();
    };
    tbDelete.onclick = ()=>{
      const tb = selectedTextbox(); if(!tb) return;
      fabricCanvas.remove(tb);
      fabricCanvas.discardActiveObject();
      fabricCanvas.requestRenderAll();
    };

    fabricCanvas.on('selection:created', syncTextControls);
    fabricCanvas.on('selection:updated', syncTextControls);
    function syncTextControls(){
      const tb = selectedTextbox();
      if (tb){
        tbContent.value = tb.text||'';
        tbFont.value = tb.fontSize||24;
        const m = tb.backgroundColor||'rgba(0,0,0,0.6)';
        const op = (m.match(/rgba?\([^,]+,[^,]+,[^,]+,([\d.]+)\)/)||[])[1];
        tbBgOpacity.value = op ? parseFloat(op) : 0.6;
      }
    }

    /* ===== Brush / Stamps (Fire, Smoke, Erase) ===== */
    const brushFireBtn = brushFire;
    const brushSmokeBtn = brushSmoke;
    const brushEraseBtn = brushErase;
    brushFireBtn.onclick = ()=> setBrushMode('fire');
    brushSmokeBtn.onclick = ()=> setBrushMode('smoke');
    brushEraseBtn.onclick = ()=> setBrushMode('erase');
    brushOff.onclick = ()=> setBrushMode('off');

    async function randomOverlayFile(cat){
      const files = await listOverlays(cat);
      if (!files.length) return null;
      const i = Math.floor(Math.random()*files.length);
      return resolveSpritePath(cat, files[i]);
    }

    function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    async function stampAt(p, cat){
      const file = await randomOverlayFile(cat);
      if (!file) return;
      const R = (parseInt(brushSize.value,10)||120)/2;
      if (lastStamp && distance(p,lastStamp) < R*0.6) return;
      lastStamp = { x:p.x, y:p.y };

      fabric.Image.fromURL(file, img=>{
        const baseW = img.width||200;
        const scale = (R*2) / baseW;
        const jitter = 0.75 + Math.random()*0.5;
        img.scale(scale*jitter);
        img.set({
          left: p.x - (img.width*img.scaleX)/2,
          top:  p.y - (img.height*img.scaleY)/2,
          angle: (Math.random()*30 - 15),
          opacity: 0.9,
          cornerStyle:'circle',
          transparentCorners:false,
          erasable:true,
          selectable:false,
          evented:false,
          shadow:'rgba(0,0,0,0.25) 0 4px 12px'
        });
        img.stampTag = cat;
        fabricCanvas.add(img);
        img.moveTo( (baseImage ? baseImage.zIndex||0 : 0) + 1 );
        fabricCanvas.requestRenderAll();
      }, { crossOrigin:'anonymous' });
    }

    function eraseStampsAt(p){
      const R = (parseInt(brushSize.value,10)||120)/2;
      const targets = fabricCanvas.getObjects('image').filter(o => o.stampTag);
      for (const obj of targets){
        const cx = obj.left + (obj.width * obj.scaleX)/2;
        const cy = obj.top  + (obj.height* obj.scaleY)/2;
        if (Math.hypot(cx - p.x, cy - p.y) <= R){
          fabricCanvas.remove(obj);
        }
      }
      fabricCanvas.requestRenderAll();
    }

    fabricCanvas.on('mouse:move', (opt)=>{
      const p = fabricCanvas.getPointer(opt.e);
      moveBrushCursor(p);
      if (pointerDown){
        if (brushMode==='fire') stampAt(p, 'fire');
        else if (brushMode==='smoke') stampAt(p, 'smoke');
        else if (brushMode==='erase') eraseStampsAt(p);
      }
    });
    fabricCanvas.on('mouse:down', (opt)=>{
      pointerDown = true;
      const p = fabricCanvas.getPointer(opt.e);
      moveBrushCursor(p);
      if (brushMode==='fire') stampAt(p, 'fire');
      else if (brushMode==='smoke') stampAt(p, 'smoke');
      else if (brushMode==='erase') eraseStampsAt(p);
    });
    fabricCanvas.on('mouse:up', ()=>{ pointerDown = false; });

    /* ===== Legacy Overlay Eraser (clip mask) with visible cursor ===== */
    let erasing=false;
    function selectedOverlay(){ const o=fabricCanvas.getActiveObject(); return (o && o.type==='image' && o!==baseImage) ? o : null; }

    function getMaskCircles(img){
      if (img.clipPath && img.clipPath.type==='group' && img.clipPath.inverted){
        return img.clipPath._objects || [];
      }
      return [];
    }
    function setMaskCircles(img, arr){
      img.set('clipPath', new fabric.Group(arr, { absolutePositioned:true, inverted:true }));
    }
    function pushUndo(img, prevArr){
      img._eraseUndoStack = img._eraseUndoStack || [];
      img._eraseRedoStack = img._eraseRedoStack || [];
      img._eraseUndoStack.push(prevArr.map(c=> new fabric.Circle({left:c.left, top:c.top, radius:c.radius, originX:'center', originY:'center', absolutePositioned:true})));
      img._eraseRedoStack.length = 0;
    }

    function applyCircle(img, p, radius){
      const prev = getMaskCircles(img);
      pushUndo(img, prev);
      const next = prev.slice();
      next.push(new fabric.Circle({ left:p.x, top:p.y, radius, originX:'center', originY:'center', absolutePositioned:true }));
      setMaskCircles(img, next);
    }

    function onMouseDown(opt){
      const img = selectedOverlay(); if(!img) return;
      pointerDown = true;
      const p = fabricCanvas.getPointer(opt.e);
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      applyCircle(img, p, r);
      fabricCanvas.requestRenderAll();
    }
    function onMouseMove(opt){
      if(!pointerDown) return;
      const img = selectedOverlay(); if(!img) return;
      const p = fabricCanvas.getPointer(opt.e);
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      applyCircle(img, p, r);
      fabricCanvas.requestRenderAll();
    }
    function onMouseUp(){ pointerDown=false; }

    function stopErasing(){
      erasing=false; pointerDown=false;
      eraserStatus.textContent='Eraser: off';
      fabricCanvas.off('mouse:down', onMouseDown);
      fabricCanvas.off('mouse:move', onMouseMove);
      fabricCanvas.off('mouse:up', onMouseUp);
      if (brushMode==='off') showBrushCursor(false);
    }

    eraserStart.onclick = ()=>{
      const img = selectedOverlay(); if(!img){ alert('Select an overlay image first.'); return; }
      setBrushMode('off');
      ensureBrushCursor();
      showBrushCursor(true);
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      brushCursor.set({ radius:r }); if (brushCursor._inner) brushCursor._inner.set({ radius:Math.max(1,r-2) });
      erasing = true;
      eraserStatus.textContent = `Eraser: ON (size ${parseInt(eraserSize.value,10)||30})`;
      fabricCanvas.on('mouse:down', onMouseDown);
      fabricCanvas.on('mouse:move', onMouseMove);
      fabricCanvas.on('mouse:up', onMouseUp);
    };
    eraserDone.onclick = stopErasing;
    eraserCancel.onclick = ()=>{ stopErasing(); fabricCanvas.renderAll(); };

    eraserSize.oninput = ()=>{
      if (!brushCursor) ensureBrushCursor();
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      brushCursor.set({ radius:r }); if (brushCursor._inner) brushCursor._inner.set({ radius:Math.max(1,r-2) });
      if (erasing) eraserStatus.textContent = `Eraser: ON (size ${parseInt(eraserSize.value,10)||30})`;
      fabricCanvas.requestRenderAll();
    };

    eraserOverlayOpacity.oninput = (e)=>{
      const img = selectedOverlay(); if(img){ img.set('opacity', parseFloat(e.target.value)); fabricCanvas.requestRenderAll(); }
    };

    eraserUndo.onclick = ()=>{
      const img = selectedOverlay(); if(!img) return;
      img._eraseUndoStack = img._eraseUndoStack || []; img._eraseRedoStack = img._eraseRedoStack || [];
      const prev = img._eraseUndoStack.pop(); if(!prev) return;
      const curr = getMaskCircles(img);
      img._eraseRedoStack.push(curr.map(c=> new fabric.Circle({left:c.left, top:c.top, radius:c.radius, originX:'center', originY:'center', absolutePositioned:true})));
      setMaskCircles(img, prev);
      fabricCanvas.requestRenderAll();
    };
    eraserRedo.onclick = ()=>{
      const img = selectedOverlay(); if(!img) return;
      img._eraseRedoStack = img._eraseRedoStack || []; img._eraseUndoStack = img._eraseUndoStack || [];
      const nxt = img._eraseRedoStack.pop(); if(!nxt) return;
      const curr = getMaskCircles(img);
      img._eraseUndoStack.push(curr.map(c=> new fabric.Circle({left:c.left, top:c.top, radius:c.radius, originX:'center', originY:'center', absolutePositioned:true})));
      setMaskCircles(img, nxt);
      fabricCanvas.requestRenderAll();
    };
    eraserClear.onclick = ()=>{
      const img = selectedOverlay(); if(!img) return;
      const curr = getMaskCircles(img);
      pushUndo(img, curr);
      setMaskCircles(img, []);
      fabricCanvas.requestRenderAll();
    };

    /* Flip */
    function flipSelected(axis){ const o=fabricCanvas.getActiveObject(); if(!o || o===baseImage) return; if(axis==='x') o.set('flipX', !o.flipX); if(axis==='y') o.set('flipY', !o.flipY); fabricCanvas.requestRenderAll(); }
    flipSelH.onclick=()=>flipSelected('x');
    flipSelV.onclick=()=>flipSelected('y');

    /* Canvas utilities */
    const rebase=()=>{ if(!baseImage) return;
      if (baseImage.type === 'image') setBaseImageFromURL(baseImage.toDataURL({}));
      if (baseImage.type === 'rect') {
        const bt = fabricCanvas.getObjects('textbox').find(o=>o.isBaseText);
        setBaseAsTextSlide(bt ? bt.text : '', bt ? bt.fontSize : 34);
      }
    };
    fitBtn.onclick=rebase;
    zoomIn.onclick=()=>fabricCanvas.setZoom(fabricCanvas.getZoom()*1.1);
    zoomOut.onclick=()=>fabricCanvas.setZoom(fabricCanvas.getZoom()/1.1);
    rotateL.onclick=()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)-90); fabricCanvas.requestRenderAll(); } };
    rotateR.onclick=()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)+90); fabricCanvas.requestRenderAll(); } };

    /* Delete stop (does not delete cloud file here—admin page handles that) */
    deleteStop.onclick=async()=>{ try{
      if(!current || stopIndex<0) return;
      if(!confirm('Delete this photo/slide from the scenario?')) return;
      const next=[...current._stops];
      next.splice(stopIndex,1);
      const updated={ ...current._raw };
      setStops(updated, next);
      await set(ref(db, `${ROOT}/${current.id}`), updated);
      current._stops=next; stopIndex=-1;
      fabricCanvas.clear(); baseImage=null;
      renderStopsThumbs();
      metaMsg.textContent='Photo/slide deleted.';
    }catch(e){ metaMsg.textContent=String(e.message||e); } };

    // Defaults
    setBrushMode('off');
    ensureBrushCursor(); showBrushCursor(false);

  })().catch(e=>ERR(e?.message||e));
  </script>
</body>
</html>

  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="Advanced editor for FireOps SIM Geo-Photo scenarios with overlays and RTDB save." />
  <meta name="theme-color" content="#0b0f14" />
  <link rel="icon" href="data:," />
  <style>
    :root{ --bg:#0b0f14; --bg2:#101726; --card:#121823; --muted:#8ea0b3; --text:#eaf2ff; --blue:#0a84ff; --teal:#2dd4bf; --red:#ff3b30; --shadow:0 12px 34px rgba(0,0,0,.38); --radius:18px; --radiusSm:14px; --border: rgba(255,255,255,.08);}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:
      radial-gradient(1400px 700px at 15% -15%, rgba(10,132,255,.28), transparent 60%),
      radial-gradient(1200px 600px at 110% 0%, rgba(255,59,48,.22), transparent 60%),
      linear-gradient(165deg, var(--bg2), var(--bg) 55%)}
    a{color:inherit;text-decoration:none}

    .topbar{position:sticky;top:0;z-index:50;background:rgba(12,15,22,.78);backdrop-filter:blur(6px) saturate(120%);border-bottom:1px solid rgba(255,255,255,.07)}
    .topnav{max-width:1200px;margin:0 auto;padding:10px 20px;display:flex;align-items:center;gap:14px;flex-wrap:wrap}
    .brandmini{display:flex;align-items:center;gap:12px;font-weight:800}
    .logo img{width:40px;height:40px;border-radius:10px;box-shadow:var(--shadow);object-fit:cover;background:#0f1624}
    .tag{color:var(--muted);font-size:12px}

    main{max-width:1200px;margin:20px auto 80px;padding:0 20px}
    .app{display:grid;grid-template-columns:320px 1fr 420px;gap:12px;align-items:start}
    .col{background:var(--card);border:1px solid var(--border);border-radius:var(--radiusSm);box-shadow:var(--shadow);padding:12px;overflow:auto}
    label{display:block;margin:8px 0 6px 2px;font-size:12px;color:var(--muted)}
    select,input,textarea,button{font-size:14px}
    select,input[type="text"],textarea{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#0d2430;color:var(--text);outline:none}
    textarea{min-height:72px;resize:vertical}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 12px;background:linear-gradient(180deg,#54a6ff,var(--blue));color:#03131b;font-weight:800;cursor:pointer;box-shadow:var(--shadow)}
    .btn.secondary{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,.18)}
    .btn.warn{background:#ffc857;color:#2a1d00}
    .btn.danger{background:var(--red);color:#ffecec}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sectionTitle{font-weight:800;margin:6px 0}
    .thumb{width:56px;height:56px;border-radius:8px;object-fit:cover;border:1px solid rgba(255,255,255,.15);cursor:pointer;background:#0b2130}
    .thumb.active{outline:3px solid var(--teal)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);color:var(--muted)}

    .canvasWrap{position:relative;background:#061621;border:1px solid rgba(255,255,255,.12);border-radius:12px;overflow:hidden}
    #c{display:block;width:100%;height:calc(100vh - 360px);background:transparent}
    .bar{display:flex;gap:8px;flex-wrap:wrap}
    .divider{height:1px;background:rgba(255,255,255,.1);opacity:.8;margin:10px 0}

    /* Overlay shelf */
    .olThumb{width:100%;aspect-ratio:1/1;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#0b2130;display:flex;align-items:center;justify-content:center;cursor:pointer}
    .olThumb img{max-width:88%;max-height:88%;display:block}
    .ol-tab.active{outline:3px solid var(--teal)}

    /* HUDs */
    #errbar{position:fixed;left:10px;bottom:10px;background:#2b0d0d;color:#ffd7d7;border:1px solid #7a2b2b;border-radius:12px;padding:8px 12px;max-width:80vw;display:none;z-index:9999}
    .overlayHUD{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:9998}
    .hudCard{min-width:220px;padding:18px;border-radius:14px;background:#0c1220;border:1px solid rgba(255,255,255,.12);box-shadow:var(--shadow);display:flex;gap:12px;align-items:center;justify-content:center;font-weight:800}
    .spinner{width:22px;height:22px;border-radius:50%;border:3px solid rgba(255,255,255,.25);border-top-color:#fff;animation:spin 0.9s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    footer{max-width:1200px;margin:40px auto;padding:18px 20px;color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,.06);display:flex;justify-content:space-between;gap:16px;flex-wrap:wrap}
    @media (max-width:1220px){ .app{grid-template-columns:1fr} #c{height:56vh} }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topnav">
      <div class="brandmini">
        <div class="logo" aria-hidden="true"><img src="/assets/logo/fire-ops-sim.png" alt="FireOps SIM logo" /></div>
        <div>
          <div style="line-height:1.1; font-size:15px; font-weight:900">FireOps SIM</div>
          <div class="tag">Real-Time Fire Scene Simulator</div>
        </div>
      </div>
    </div>
  </div>

  <main>
    <div id="errbar"></div>

    <!-- Loading & Saving HUDs -->
    <div id="loadingHUD" class="overlayHUD" aria-hidden="true">
      <div class="hudCard"><div class="spinner"></div><div id="loadingLabel">Loading…</div></div>
    </div>
    <div id="savingHUD" class="overlayHUD" aria-hidden="true">
      <div class="hudCard"><div class="spinner"></div><div>Saving…</div></div>
    </div>

    <div id="app" class="app">
      <!-- Left: scenario + meta -->
      <div class="col" id="leftCol">
        <div class="row" style="justify-content:space-between">
          <div class="pill" id="statusPill">Loading…</div>
          <button id="refresh" class="btn secondary">Refresh</button>
        </div>

        <label>Scenario</label>
        <select id="scenarioSel"><option value="">Select scenario…</option></select>

        <!-- Scenario-level dispatch editor -->
        <div class="divider"></div>
        <div class="sectionTitle">Scenario Dispatch</div>
        <label>Dispatch Text</label>
        <textarea id="scenarioDispatch" placeholder="Ex: Engine 1 dispatched to a residential structure fire..."></textarea>
        <div class="row">
          <label class="pill" for="scenarioDispatchTTS" style="cursor:pointer">Read via TTS</label>
          <input id="scenarioDispatchTTS" type="checkbox" />
          <button id="saveScenarioMeta" class="btn">Save Scenario</button>
        </div>
        <div id="scenarioMetaMsg" class="pill" style="margin-top:6px">Ready</div>

        <div class="divider"></div>
        <div class="row" style="justify-content:space-between">
          <div class="sectionTitle">Photos / Slides in scenario</div>
          <button id="addTextSlide" class="btn secondary">+ Add Text Slide</button>
        </div>
        <div id="stopList" class="row"></div>

        <div class="divider"></div>
        <div class="sectionTitle">Selected stop meta</div>
        <label>Title</label><input id="stopTitle" type="text" />
        <label>Caption</label><textarea id="stopCaption"></textarea>

        <!-- Text Slide panel (conditional) -->
        <div id="textSlidePanel" style="display:none">
          <div class="sectionTitle">Text Slide</div>
          <label>Text Content</label>
          <textarea id="textSlideContent" placeholder="Type the slide text here…"></textarea>
          <div class="row">
            <div class="pill"><input id="textSlideManual" type="checkbox" /> <span>Manual mode (ignore GPS)</span></div>
            <div class="pill"><input id="textSlideTTS" type="checkbox" checked /> <span>TTS for this slide</span></div>
          </div>
          <label>Font Size</label>
          <input id="textSlideFontSize" type="range" min="18" max="72" step="2" value="34" />
          <div class="row" style="margin-top:6px">
            <button id="renderTextPreview" class="btn secondary">Render Preview</button>
          </div>
          <div id="textSlideMsg" class="pill" style="margin-top:6px">Text slide ready</div>
          <div class="divider"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Latitude</label><input id="stopLat" type="text" /></div>
          <div style="flex:1"><label>Longitude</label><input id="stopLng" type="text" /></div>
        </div>
        <label>Radius (meters)</label><input id="stopRadius" type="text" placeholder="50" />
        <div class="row" style="margin-top:6px">
          <button id="useGPS" class="btn secondary">Use my location</button>
          <button id="saveMeta" class="btn">Save Meta</button>
        </div>
        <div id="metaMsg" class="pill" style="margin-top:6px">Ready</div>

        <div class="divider"></div>
        <div class="row" id="replaceRow">
          <input id="replaceFile" type="file" accept="image/*" />
          <button id="replaceApply" class="btn">Replace Image</button>
        </div>
        <div class="row" style="margin-top:6px">
          <button id="deleteStop" class="btn danger">Delete This Photo/Slide</button>
          <button id="exportPNG" class="btn secondary">Export PNG</button>
        </div>
      </div>

      <!-- Center: canvas -->
      <div class="col">
        <div class="bar" style="margin-bottom:8px">
          <button id="fit" class="btn secondary">Fit</button>
          <button id="zoomIn" class="btn secondary">Zoom +</button>
          <button id="zoomOut" class="btn secondary">Zoom −</button>
          <button id="rotateL" class="btn secondary">Rotate ⟲</button>
          <button id="rotateR" class="btn secondary">Rotate ⟳</button>
          <span class="pill" id="canvasInfo">Canvas</span>
          <button id="saveImage" class="btn">Save Image to RTDB</button>
        </div>
        <div class="canvasWrap"><canvas id="c"></canvas></div>
      </div>

      <!-- Right: overlays + brush + text + eraser + flip -->
      <div class="col" id="rightCol">
        <div class="sectionTitle">Overlays</div>
        <div class="row" style="gap:6px; flex-wrap:nowrap; overflow:auto">
          <button class="btn secondary ol-tab" data-cat="fire">🔥 Fire</button>
          <button class="btn secondary ol-tab" data-cat="smoke">🌫️ Smoke</button>
          <button class="btn secondary ol-tab" data-cat="people">🧍 People</button>
          <button class="btn secondary ol-tab" data-cat="cars">🚗 Cars</button>
          <button class="btn secondary ol-tab" data-cat="hazard">⚠️ Hazard</button>
        </div>
        <div id="overlayShelf" style="margin-top:8px; display:grid; grid-template-columns:repeat(3, 1fr); gap:8px"></div>

        <label style="margin-top:10px">Hue (selected overlay image)</label>
        <input id="overlayHue" type="range" min="-180" max="180" step="1" value="0" />

        <label style="margin-top:10px">Opacity (selected overlay)</label>
        <input id="overlayOpacity" type="range" min="0.05" max="1" step="0.05" value="1" />

        <div class="row" style="margin-top:8px">
          <button id="bringFront" class="btn secondary">Bring to Front</button>
          <button id="sendBack" class="btn secondary">Send to Back</button>
          <button id="deleteObj" class="btn danger">Delete Selected</button>
        </div>

        <div class="divider"></div>
        <div class="sectionTitle">Brush / Stamps</div>
        <div class="row">
          <button id="brushFire" class="btn secondary">🔥 Fire Brush</button>
          <button id="brushSmoke" class="btn secondary">🌫️ Smoke Brush</button>
          <button id="brushErase" class="btn secondary">🧽 Erase Stamps</button>
          <button id="brushOff" class="btn secondary">✖ Off</button>
        </div>
        <label style="margin-top:8px">Brush Size <span id="brushSizeReadout" class="pill" style="margin-left:6px">120 px</span></label>
        <input id="brushSize" type="range" min="24" max="320" step="4" value="120" />

        <div class="divider"></div>
        <div class="sectionTitle">Text Boxes</div>
        <div class="row">
          <button id="addTextbox" class="btn secondary">+ Add Text Box</button>
        </div>
        <label>Selected Text</label>
        <textarea id="tbContent" placeholder="Type information (patient vitals, notes, etc.)…"></textarea>
        <label>Font Size</label>
        <input id="tbFont" type="range" min="12" max="72" step="1" value="24" />
        <label>Background Opacity</label>
        <input id="tbBgOpacity" type="range" min="0" max="1" step="0.05" value="0.6" />
        <div class="row" style="margin-top:6px">
          <button id="tbApply" class="btn">Apply to Selected</button>
          <button id="tbDelete" class="btn danger">Delete Text Box</button>
        </div>

        <div class="divider"></div>
        <div class="sectionTitle">Eraser (selected overlay)</div>
        <div class="row">
          <button id="eraserStart" class="btn warn">Start</button>
          <button id="eraserDone" class="btn">Finish</button>
          <button id="eraserCancel" class="btn secondary">Cancel</button>
        </div>
        <label style="margin-top:8px">Brush Size (overlay eraser)</label>
        <input id="eraserSize" type="range" min="5" max="120" step="1" value="30" />
        <label style="margin-top:8px">Overlay Opacity</label>
        <input id="eraserOverlayOpacity" type="range" min="0.05" max="1" step="0.05" value="1" />
        <div class="row" style="margin-top:8px">
          <button id="eraserUndo" class="btn secondary">Undo Erase</button>
          <button id="eraserRedo" class="btn secondary">Redo Erase</button>
          <button id="eraserClear" class="btn secondary">Clear Erase</button>
        </div>
        <div class="pill" id="eraserStatus" style="margin-top:6px">Eraser: off</div>

        <div class="divider"></div>
        <div class="sectionTitle">Transform Overlay</div>
        <div class="row">
          <button id="flipSelH" class="btn secondary">Flip H</button>
          <button id="flipSelV" class="btn secondary">Flip V</button>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <div>© <span id="year"></span> FireOps SIM</div>
    <div class="external">Part of the <a href="https://emscodesim.com" rel="noopener">EMS Code Sim</a> training ecosystem</div>
  </footer>

  <!-- Fabric 5.x -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script type="module">
  /* Error banner */
  const ERR = (msg) => { const b=document.getElementById('errbar'); b.textContent=msg; b.style.display='block'; };

  (async () => {
    document.getElementById('year').textContent = new Date().getFullYear();

    const loadingHUD = document.getElementById('loadingHUD');
    const loadingLabel = document.getElementById('loadingLabel');
    const savingHUD  = document.getElementById('savingHUD');
    const showLoading = (t='Loading…')=>{ loadingLabel.textContent=t; loadingHUD.style.display='flex'; };
    const hideLoading = ()=>{ loadingHUD.style.display='none'; };
    const showSaving  = ()=>{ savingHUD.style.display='flex'; };
    const hideSaving  = ()=>{ savingHUD.style.display='none'; };

    /* Firebase */
    const [{ initializeApp }] = await Promise.all([ import("https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js") ]);
    const [{ getDatabase, ref, onValue, get, set }] = await Promise.all([ import("https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js") ]);
    const firebaseConfig = {
      apiKey:"AIzaSyDM6DpRSeZueVKRpbyJyDmhf8WY66KyCDk",
      authDomain:"dailyquiz-d5279.firebaseapp.com",
      databaseURL:"https://dailyquiz-d5279-default-rtdb.firebaseio.com",
      projectId:"dailyquiz-d5279",
      appId:"1:94577748034:web:c032d3a1d72db1313de5db",
      measurementId:"G-19DVN7NNH7"
    };
    const appFB = initializeApp(firebaseConfig);
    const db = getDatabase(appFB);

    /* DOM Refs */
    const statusPill=document.getElementById('statusPill');
    const scenarioSel=document.getElementById('scenarioSel');
    const stopList=document.getElementById('stopList');
    const refreshBtn=document.getElementById('refresh');

    const scenarioDispatch=document.getElementById('scenarioDispatch');
    const scenarioDispatchTTS=document.getElementById('scenarioDispatchTTS');
    const saveScenarioMeta=document.getElementById('saveScenarioMeta');
    const scenarioMetaMsg=document.getElementById('scenarioMetaMsg');
    const addTextSlide=document.getElementById('addTextSlide');

    const stopTitle=document.getElementById('stopTitle');
    const stopCaption=document.getElementById('stopCaption');

    const textSlidePanel=document.getElementById('textSlidePanel');
    const textSlideContent=document.getElementById('textSlideContent');
    const textSlideManual=document.getElementById('textSlideManual');
    const textSlideTTS=document.getElementById('textSlideTTS');
    const textSlideFontSize=document.getElementById('textSlideFontSize');
    const renderTextPreview=document.getElementById('renderTextPreview');
    const textSlideMsg=document.getElementById('textSlideMsg');

    const stopLat=document.getElementById('stopLat');
    const stopLng=document.getElementById('stopLng');
    const stopRadius=document.getElementById('stopRadius');
    const useGPS=document.getElementById('useGPS');
    const saveMeta=document.getElementById('saveMeta');
    const metaMsg=document.getElementById('metaMsg');

    const replaceRow=document.getElementById('replaceRow');
    const replaceFile=document.getElementById('replaceFile');
    const replaceApply=document.getElementById('replaceApply');
    const deleteStop=document.getElementById('deleteStop');
    const exportPNG=document.getElementById('exportPNG');

    const cInfo=document.getElementById('canvasInfo');
    const fitBtn=document.getElementById('fit');
    const zoomIn=document.getElementById('zoomIn');
    const zoomOut=document.getElementById('zoomOut');
    const rotateL=document.getElementById('rotateL');
    const rotateR=document.getElementById('rotateR');
    const saveImage=document.getElementById('saveImage');

    const overlayShelf=document.getElementById('overlayShelf');
    const tabBtns = Array.from(document.querySelectorAll('.ol-tab'));
    const overlayHue=document.getElementById('overlayHue');
    const overlayOpacity=document.getElementById('overlayOpacity');
    const bringFront=document.getElementById('bringFront');
    const sendBack=document.getElementById('sendBack');
    const deleteObj=document.getElementById('deleteObj');

    const eraserStart=document.getElementById('eraserStart');
    const eraserDone=document.getElementById('eraserDone');
    const eraserCancel=document.getElementById('eraserCancel');
    const eraserSize=document.getElementById('eraserSize');
    const eraserOverlayOpacity=document.getElementById('eraserOverlayOpacity');
    const eraserUndo=document.getElementById('eraserUndo');
    const eraserRedo=document.getElementById('eraserRedo');
    const eraserClear=document.getElementById('eraserClear');
    const eraserStatus=document.getElementById('eraserStatus');
    const flipSelH=document.getElementById('flipSelH');
    const flipSelV=document.getElementById('flipSelV');

    /* Brush & TextBox controls */
    const brushFire=document.getElementById('brushFire');
    const brushSmoke=document.getElementById('brushSmoke');
    const brushErase=document.getElementById('brushErase');
    const brushOff=document.getElementById('brushOff');
    const brushSize=document.getElementById('brushSize');
    const brushSizeReadout=document.getElementById('brushSizeReadout');

    const addTextbox=document.getElementById('addTextbox');
    const tbContent=document.getElementById('tbContent');
    const tbFont=document.getElementById('tbFont');
    const tbBgOpacity=document.getElementById('tbBgOpacity');
    const tbApply=document.getElementById('tbApply');
    const tbDelete=document.getElementById('tbDelete');

    /* Canvas */
    const fabricCanvas = new fabric.Canvas('c', { backgroundColor:'#061621', preserveObjectStacking:true, selection:true });
    let baseImage=null; // fabric.Image or fabric.Rect for text slides

    /* Brush state */
    let brushMode = 'off'; // 'fire' | 'smoke' | 'erase' | 'off'
    let pointerDown = false;
    let lastStamp = null; // {x,y}
    let brushCursor = null;
    const STAMP_GROUP = 'stampLayer'; // tag for brush stamps

    function ensureBrushCursor(){
      const r = (parseInt(brushSize.value,10)||120)/2;
      if (!brushCursor){
        brushCursor = new fabric.Circle({
          left:-1000, top:-1000, radius:r,
          fill:'rgba(255,255,255,0.08)',
          stroke:'rgba(255,255,255,0.85)',
          strokeWidth:1.5,
          selectable:false, evented:false, excludeFromExport:true,
          hoverCursor:'none'
        });
        // Double ring for clearer edge
        const inner = new fabric.Circle({
          radius: Math.max(1, r-2), left:-1000, top:-1000,
          fill:'transparent', stroke:'rgba(0,0,0,0.6)', strokeWidth:1,
          selectable:false, evented:false, excludeFromExport:true
        });
        inner._isInnerRing = true;
        brushCursor._inner = inner;
        fabricCanvas.add(brushCursor);
        fabricCanvas.add(inner);
        brushCursor.moveTo(99999);
        inner.moveTo(99999);
      }
      brushCursor.set({ radius:r });
      if (brushCursor._inner){ brushCursor._inner.set({ radius:Math.max(1,r-2) }); }
      fabricCanvas.requestRenderAll();
    }
    function showBrushCursor(show){
      if (!brushCursor) ensureBrushCursor();
      const out = show ? 1 : 0;
      brushCursor.set({ opacity: out });
      if (brushCursor._inner) brushCursor._inner.set({ opacity: out });
    }
    function moveBrushCursor(p){
      if (!brushCursor) return;
      brushCursor.set({ left:p.x - brushCursor.radius, top:p.y - brushCursor.radius });
      if (brushCursor._inner) brushCursor._inner.set({ left: p.x - brushCursor._inner.radius, top: p.y - brushCursor._inner.radius });
    }

    function setBrushMode(mode){
      brushMode = mode;
      [brushFire,brushSmoke,brushErase,brushOff].forEach(b=>b.classList.remove('active'));
      const map = { fire:brushFire, smoke:brushSmoke, erase:brushErase, off:brushOff };
      (map[mode]||brushOff).classList.add('active');
      // Disable selection while brushing
      const brushing = (mode!=='off');
      fabricCanvas.skipTargetFind = brushing;
      fabricCanvas.selection = !brushing;
      showBrushCursor(brushing);
      lastStamp = null;
      // Ensure the legacy overlay eraser is off to avoid conflicts
      stopErasing();
    }

    brushSize.oninput = ()=>{
      brushSizeReadout.textContent = (parseInt(brushSize.value,10)||120) + ' px';
      ensureBrushCursor();
    };

    /* Fit / Resize */
    function fitCanvas(){
      const reserved = 260;
      const targetH = Math.max(380, window.innerHeight - reserved);
      document.getElementById('c').style.height = targetH + 'px';
      fabricCanvas.setHeight(targetH);
      const midCol = document.querySelector('main .col:nth-child(2)');
      const width = (midCol?.clientWidth || 800) - 24;
      fabricCanvas.setWidth(width);
      if (baseImage && baseImage.type === 'rect') {
        baseImage.set({ left:0, top:0, width:fabricCanvas.getWidth(), height:fabricCanvas.getHeight() });
        const baseText = fabricCanvas.getObjects('textbox').find(o => o.isBaseText);
        if (baseText){
          baseText.set({
            width: Math.floor(fabricCanvas.getWidth()*0.8),
            left: Math.floor(fabricCanvas.getWidth()*0.1),
            top:  Math.floor(fabricCanvas.getHeight()*0.2)
          });
        }
      }
      ensureBrushCursor();
      fabricCanvas.calcOffset();
      fabricCanvas.requestRenderAll();
    }
    fitCanvas(); window.addEventListener('resize', fitCanvas);

    function setBaseImageFromDataURL(dataURL){
      return new Promise((resolve,reject)=>{
        fabric.Image.fromURL(dataURL, (img)=>{
          if (!img) { reject(new Error('Image load failed')); return; }
          if (baseImage) fabricCanvas.remove(baseImage);
          baseImage = img; baseImage.selectable=false; baseImage.evented=false; baseImage.set('erasable', false);
          const cw=fabricCanvas.getWidth(), ch=fabricCanvas.getHeight();
          const scale=Math.min(cw/img.width, ch/img.height);
          baseImage.scale(scale);
          baseImage.set({ left:(cw - img.width*scale)/2, top:(ch - img.height*scale)/2 });
          fabricCanvas.add(baseImage); baseImage.moveTo(0); fabricCanvas.requestRenderAll();
          cInfo.textContent=`Image ${Math.round(img.width)}×${Math.round(img.height)} (scale ${scale.toFixed(2)})`;
          resolve();
        }, { crossOrigin:'anonymous' });
      });
    }

    // Render a text slide as black background + centered white text
    function setBaseAsTextSlide(text, fontSize=34){
      fabricCanvas.clear();
      const rect = new fabric.Rect({
        left:0, top:0, width:fabricCanvas.getWidth(), height:fabricCanvas.getHeight(),
        fill:'#000', selectable:false, evented:false, erasable:false
      });
      baseImage = rect;
      const tb = new fabric.Textbox(text||'', {
        width: Math.floor(fabricCanvas.getWidth()*0.8),
        left: Math.floor(fabricCanvas.getWidth()*0.1),
        top:  Math.floor(fabricCanvas.getHeight()*0.2),
        fontSize: fontSize||34,
        fill:'#fff', textAlign:'center',
        fontFamily:'system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif',
        selectable:false, evented:false, erasable:false
      });
      tb.isBaseText = true;
      fabricCanvas.add(rect); fabricCanvas.add(tb);
      rect.moveTo(0);
      fabricCanvas.requestRenderAll();
      cInfo.textContent='Text slide';
    }

    /* === SMART FULL-RES EXPORT (keeps payload under ~9 MB) === */
    function encodeCanvasForRTDB() {
      const MAX_BYTES = 9_000_000;
      const zoom = fabricCanvas.getZoom() || 1;
      let multiplier = 1;
      if (baseImage) {
        const s = baseImage.scaleX || 1;
        multiplier = (1 / s) * (1 / zoom);
      }
      multiplier = Math.max(1, Math.min(8, multiplier));

      const bytesOf = (b64) => Math.floor((b64.length * 3) / 4);

      let url = fabricCanvas.toDataURL({ format:'png', quality:1, multiplier });
      let b64 = url.split(',')[1] || '';
      if (bytesOf(b64) <= MAX_BYTES) return { format:'png', data:b64 };

      const qSteps = [0.95, 0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6];
      for (const q of qSteps) {
        url = fabricCanvas.toDataURL({ format:'jpeg', quality:q, multiplier });
        b64 = url.split(',')[1] || '';
        if (bytesOf(b64) <= MAX_BYTES) return { format:'jpeg', data:b64 };
      }
      let m = multiplier;
      while (m > 0.7) {
        m *= 0.85;
        for (const q of qSteps) {
          url = fabricCanvas.toDataURL({ format:'jpeg', quality:q, multiplier:m });
          b64 = url.split(',')[1] || '';
          if (bytesOf(b64) <= MAX_BYTES) return { format:'jpeg', data:b64 };
        }
      }
      url = fabricCanvas.toDataURL({ format:'jpeg', quality:0.5, multiplier:Math.max(0.6, m) });
      b64 = url.split(',')[1] || '';
      return { format:'jpeg', data:b64 };
    }

    function toDataURLFromStored(stored) {
      if (typeof stored === 'string') return stored;
      if (!stored || !stored.data) return '';
      const fmt = stored.format === 'jpeg' ? 'jpeg' : 'png';
      return `data:image/${fmt};base64,${stored.data}`;
    }

    exportPNG.onclick = () => {
      const enc = encodeCanvasForRTDB();
      const url = `data:image/${enc.format};base64,${enc.data}`;
      const a = document.createElement('a');
      a.href = url;
      a.download = 'image-edited.' + (enc.format === 'jpeg' ? 'jpg' : 'png');
      a.click();
    };

    /* Scenarios */
    function coerceStops(sc){
      if (Array.isArray(sc?.stops))  return sc.stops;
      if (Array.isArray(sc?.photos)) return sc.photos;
      if (Array.isArray(sc?.images)) return sc.images;
      return [];
    }
    function setStops(sc, stops){
      if (Array.isArray(sc?.stops)) sc.stops = stops;
      else if (Array.isArray(sc?.photos)) sc.photos = stops;
      else if (Array.isArray(sc?.images)) sc.images = stops;
      else sc.stops = stops;
    }

    let scenarios=[], current=null, stopIndex=-1;
    const ROOT='scenarios';

    function showStatus(msg){ statusPill.textContent = msg; }
    function populateList(){
      scenarioSel.innerHTML = '<option value="">Select scenario…</option>';
      scenarios.forEach(sc => {
        const o=document.createElement('option'); o.value=sc.id; o.textContent=(sc.title||'(untitled)') + (sc.active? '':' (inactive)');
        scenarioSel.appendChild(o);
      });
    }

    function textThumbDataURL(text){
      const t = (text || 'TEXT').split('\n')[0].slice(0,18);
      const svg = `
        <svg xmlns='http://www.w3.org/2000/svg' width='80' height='80'>
          <rect width='100%' height='100%' fill='#000'/>
          <rect x='6' y='6' width='68' height='20' rx='6' fill='#0a84ff'/>
          <text x='40' y='21' fill='#001' font-size='12' text-anchor='middle' font-weight='700'>TEXT</text>
          <text x='40' y='50' fill='#fff' font-size='10' text-anchor='middle'>${t.replace(/&/g,'&amp;')}</text>
        </svg>`;
      return "data:image/svg+xml;utf8," + encodeURIComponent(svg);
    }

    function renderStopsThumbs(){
      stopList.innerHTML='';
      if(!current || !current._stops?.length){ stopList.innerHTML='<div class="pill">No photos/slides</div>'; return; }
      current._stops.forEach((s,idx)=>{
        const img=document.createElement('img');
        img.className='thumb'+(idx===stopIndex?' active':'');
        const isText = s?.type === 'text';
        const src = isText ? textThumbDataURL(s.text||s.title||'') : toDataURLFromStored(s.imageData || s.imageURL);
        img.src=src||textThumbDataURL(s?.title||'');
        img.title=(s.title||`Stop ${idx+1}`) + (isText?' (Text slide)':'');
        img.onerror=()=>{ img.src=textThumbDataURL(s?.title||''); };
        img.onclick=()=>loadStop(idx);
        stopList.appendChild(img);
      });
    }

    async function loadScenarios(){
      try{
        showLoading('Loading scenarios…');
        const snap = await get(ref(db, ROOT));
        const obj = snap.exists() ? (snap.val()||{}) : {};
        scenarios = Object.entries(obj).map(([id, s])=>({
          id, _raw:s, _stops:coerceStops(s), ...s
        })).sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
        populateList();
        showStatus(`${scenarios.length} scenario(s) loaded`);
      }catch(e){
        showStatus('Error: ' + (e?.message || e));
        ERR(e?.message || e);
      } finally { hideLoading(); }
    }

    function startLive(){
      onValue(ref(db, ROOT), snap=>{
        const v=snap.val()||{};
        scenarios = Object.entries(v).map(([id,s])=>({
          id, _raw:s, _stops:coerceStops(s), ...s
        })).sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
        populateList();
        if (current){
          const fresh = scenarios.find(sc=>sc.id===current.id);
          if (fresh){ current=fresh; renderStopsThumbs(); }
        }
        showStatus(`${scenarios.length} scenario(s) loaded`);
      }, err=> showStatus('RTDB onValue error: '+(err?.message||err)));
    }

    await loadScenarios();
    startLive();
    refreshBtn.onclick = loadScenarios;

    function applyScenarioMetaToUI(){
      if (!current){ scenarioDispatch.value=''; scenarioDispatchTTS.checked=false; return; }
      const raw = current._raw || {};
      scenarioDispatch.value = raw.dispatchText || '';
      scenarioDispatchTTS.checked = !!raw.dispatchTTS;
    }

    scenarioSel.onchange = async ()=>{
      const id=scenarioSel.value;
      current = scenarios.find(s=>s.id===id) || null;
      stopIndex=-1;
      renderStopsThumbs();
      applyScenarioMetaToUI();
      fabricCanvas.clear(); baseImage=null;
      fitCanvas();
    };

    // Save scenario-level meta (dispatch text + TTS)
    saveScenarioMeta.onclick = async () => {
      try{
        if (!current) throw new Error('Select a scenario first.');
        showSaving();
        const updated = { ...current._raw, dispatchText: scenarioDispatch.value.trim(), dispatchTTS: !!scenarioDispatchTTS.checked };
        await set(ref(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated;
        scenarioMetaMsg.textContent = 'Scenario saved.';
      }catch(e){
        scenarioMetaMsg.textContent = 'Error: ' + (e?.message||e);
      }finally{ hideSaving(); }
    };

    // Create & add a new text slide
    addTextSlide.onclick = async ()=>{
      try{
        if (!current) throw new Error('Select a scenario first.');
        showSaving();
        const nextStops = [ ...current._stops ];
        const newStop = {
          type:'text',
          title:'Text Slide',
          caption:'',
          text:'New slide text',
          fontSize:34,
          manual:true,   // manual by default
          tts:true,
          lat:null, lng:null,
          radiusMeters:50,
          overlays:[]
        };
        nextStops.push(newStop);
        const updated = { ...current._raw };
        setStops(updated, nextStops);
        await set(ref(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated; current._stops = nextStops;
        renderStopsThumbs();
        stopIndex = nextStops.length - 1;
        await loadStop(stopIndex);
        scenarioMetaMsg.textContent = 'Text slide added.';
      }catch(e){
        scenarioMetaMsg.textContent = 'Error: ' + (e?.message||e);
      }finally{ hideSaving(); }
    };

    function isTextStop(s){ return s && s.type === 'text'; }

    function updateStopMetaPanelUI(s){
      const textMode = isTextStop(s);
      textSlidePanel.style.display = textMode ? '' : 'none';
      replaceRow.style.display = textMode ? 'none' : '';
    }

    async function loadStop(idx){
      if(!current) return;
      const s=current._stops[idx]; if(!s) return;
      stopIndex=idx;

      // Common meta
      stopTitle.value=s.title||'';
      stopCaption.value=s.caption||'';
      stopLat.value=(s.lat ?? '').toString();
      stopLng.value=(s.lng ?? '').toString();
      stopRadius.value=(s.radiusMeters ?? s.radius ?? 50).toString();

      // Text slide meta
      textSlideContent.value = isTextStop(s) ? (s.text||'') : '';
      textSlideFontSize.value = isTextStop(s) ? (s.fontSize||34) : 34;
      textSlideManual.checked = !!s.manual;
      textSlideTTS.checked = !!s.tts;

      Array.from(stopList.children).forEach((n,i)=>n.classList.toggle('active', i===idx));
      fabricCanvas.clear(); baseImage=null;

      updateStopMetaPanelUI(s);

      const src = toDataURLFromStored(s.imageData || s.imageURL);

      if (isTextStop(s)){
        setBaseAsTextSlide(s.text||'', s.fontSize||34);
      } else {
        if(!src){ metaMsg.textContent='No image in this stop.'; return; }
        showLoading('Loading photo…');
        await setBaseImageFromDataURL(src);
      }

      // Rehydrate overlays (images + text) + erase masks on images
      if (Array.isArray(s.overlays)) {
        for (const ov of s.overlays){
          if (ov?.kind === 'text'){
            // Textbox overlay
            const tb = new fabric.Textbox(ov.text||'', {
              left: ov.left||100, top: ov.top||100,
              scaleX: ov.scaleX||1, scaleY: ov.scaleY||1,
              angle: ov.angle||0, opacity: ov.opacity??1,
              fontSize: ov.fontSize||24,
              fill: ov.fill||'#fff',
              backgroundColor: ov.backgroundColor || 'rgba(0,0,0,0.6)',
              padding: ov.padding ?? 8,
              cornerStyle:'circle', transparentCorners:false,
              editable:true
            });
            tb._kind='text';
            fabricCanvas.add(tb);
            continue;
          }
          // Image overlay
          if (!ov?.src) continue;
          await new Promise(res=>{
            fabric.Image.fromURL(ov.src, img=>{
              try{
                img.set({
                  left:ov.left||0, top:ov.top||0,
                  scaleX:ov.scaleX||1, scaleY:ov.scaleY||1,
                  angle:ov.angle||0, opacity:ov.opacity??1,
                  flipX:!!ov.flipX, flipY:!!ov.flipY,
                  erasable:true, cornerStyle:'circle', transparentCorners:false
                });
                if (Array.isArray(ov.erase) && ov.erase.length){
                  const circles = ov.erase.map(e => new fabric.Circle({
                    left: e.x, top: e.y, radius: e.r,
                    originX:'center', originY:'center', absolutePositioned:true
                  }));
                  img.set('clipPath', new fabric.Group(circles, { absolutePositioned:true, inverted:true }));
                }
                img._eraseUndoStack = []; img._eraseRedoStack = [];
                if (ov.stampTag) img.stampTag = ov.stampTag; // preserve stamp tag
                fabricCanvas.add(img);
              } finally { res(); }
            }, { crossOrigin:'anonymous' });
          });
        }
        fabricCanvas.requestRenderAll();
      }
      hideLoading();
    }

    /* GPS + Meta save */
    useGPS.onclick=()=>{ navigator.geolocation.getCurrentPosition(p=>{ stopLat.value=p.coords.latitude.toFixed(6); stopLng.value=p.coords.longitude.toFixed(6); metaMsg.textContent='GPS captured.'; }, e=>{ metaMsg.textContent='GPS error: '+e.message; }, { enableHighAccuracy:true, timeout:10000 }); };

    function serializeOverlays(){
      const out=[];
      fabricCanvas.getObjects().forEach(obj=>{
        if (obj===baseImage) return;
        if (obj.isBaseText) return;
        if (obj.type === 'image'){
          let erase = null;
          if (obj.clipPath && obj.clipPath.type === 'group' && obj.clipPath.inverted) {
            erase = (obj.clipPath._objects || []).map(o => ({
              type: o.type, x: o.left, y: o.top, r: o.radius || 0,
            }));
          }
          out.push({
            kind:'image',
            src: obj.getSrc ? obj.getSrc() : obj._originalElement?.src || obj.src || '',
            left: obj.left||0, top: obj.top||0,
            scaleX: obj.scaleX||1, scaleY: obj.scaleY||1,
            angle: obj.angle||0, opacity: obj.opacity??1,
            flipX: !!obj.flipX,  flipY: !!obj.flipY,
            erase,
            stampTag: obj.stampTag || null
          });
        } else if (obj.type === 'textbox'){
          out.push({
            kind:'text',
            text: obj.text || '',
            left: obj.left||0, top: obj.top||0,
            scaleX: obj.scaleX||1, scaleY: obj.scaleY||1,
            angle: obj.angle||0, opacity: obj.opacity??1,
            fontSize: obj.fontSize||24,
            fill: obj.fill||'#fff',
            backgroundColor: obj.backgroundColor || 'rgba(0,0,0,0.6)',
            padding: obj.padding ?? 8
          });
        }
      });
      return out;
    }

    saveMeta.onclick=async()=>{ try{
      if(!current || stopIndex<0) throw new Error('Select a stop first.');
      showSaving();
      const isText = isTextStop(current._stops[stopIndex]);
      const s = { ...current._stops[stopIndex] };
      s.title=stopTitle.value.trim();
      s.caption=stopCaption.value.trim();

      if (isText){
        s.type='text';
        s.text = textSlideContent.value;
        s.fontSize = parseInt(textSlideFontSize.value,10) || 34;
        s.tts = !!textSlideTTS.checked;
        s.manual = !!textSlideManual.checked;
      }

      s.lat = (stopLat.value.trim()==='' ? null : parseFloat(stopLat.value));
      s.lng = (stopLng.value.trim()==='' ? null : parseFloat(stopLng.value));
      s.radiusMeters=Math.max(5, Math.min(1000, Math.round(parseInt(stopRadius.value||'50',10))));
      if( (s.lat!==null && Number.isNaN(s.lat)) || (s.lng!==null && Number.isNaN(s.lng)) ) throw new Error('Invalid GPS coordinates.');

      s.overlays = serializeOverlays();

      const nextStops = [ ...current._stops ]; nextStops[stopIndex] = s;
      const updated = { ...current._raw };
      setStops(updated, nextStops);
      await set(ref(db, `${ROOT}/${current.id}`), updated);
      current._raw = updated; current._stops = nextStops;
      renderStopsThumbs();

      if (isText) setBaseAsTextSlide(s.text, s.fontSize);

      metaMsg.textContent='Meta saved.';
    }catch(err){ metaMsg.textContent=String(err.message||err); }
     finally { hideSaving(); } };

    function readFileAsDataURL(f){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f); }); }
    replaceApply.onclick=async()=>{ const f=replaceFile.files?.[0]; if(!f){ metaMsg.textContent='Choose a file first.'; return; } const data=await readFileAsDataURL(f); await setBaseImageFromDataURL(data); };

    async function persistCurrentStopImageAndOverlays(){
      if(!current || stopIndex<0) throw new Error('Select a stop first.');
      showSaving();
      try{
        const enc = encodeCanvasForRTDB();
        const s = { ...current._stops[stopIndex] };
        s.imageData = enc;   // { format, data } — compact & RTDB-safe
        s.imageURL  = null;
        s.overlays  = serializeOverlays();

        const nextStops = [ ...current._stops ]; nextStops[stopIndex] = s;
        const updated = { ...current._raw };
        setStops(updated, nextStops);
        await set(ref(db, `${ROOT}/${current.id}`), updated);
        current._raw = updated; current._stops = nextStops;
        renderStopsThumbs();
        metaMsg.textContent='Image/slide + overlays saved.';
      } finally { hideSaving(); }
    }
    saveImage.onclick=()=>persistCurrentStopImageAndOverlays().catch(e=> metaMsg.textContent=String(e.message||e));

    // Re-render text preview without saving
    renderTextPreview.onclick = ()=>{
      const txt = textSlideContent.value;
      const fs = parseInt(textSlideFontSize.value,10) || 34;
      setBaseAsTextSlide(txt, fs);
      textSlideMsg.textContent = 'Preview updated (not yet saved).';
    };

    /* Overlay shelf — dynamic, no hardcoding */
    const OVERLAY_BASE = 'https://fireopssim.com/geophoto/overlays/';
    // NOTE: cars folder fixed to "cars"
    const FOLDER_MAP = { cars:'cars', people:'people', fire:'fire', smoke:'smoke', hazard:'hazard' };
    const CAT_PREFIX = { fire:'fire', smoke:'smoke', people:'person', cars:'car', hazard:'hazard' };
    const EXTENSIONS = ['png','webp','jpg','jpeg'];
    const OVERLAY_CACHE = Object.create(null);

    function resolveFolder(cat){ return (FOLDER_MAP[cat] || cat); }
    function resolveSpritePath(cat, name){ return `${OVERLAY_BASE}${resolveFolder(cat)}/${name}`; }

    async function listFromManifest(baseUrl, folder){
      const candidates = [`${baseUrl}index.json`, `${baseUrl}_index.json`];
      for (const url of candidates){
        try{
          const r = await fetch(url, { cache:'no-store' });
          if (r.ok && (r.headers.get('content-type')||'').includes('application/json')){
            const j = await r.json();
            if (Array.isArray(j)) return j;
            if (Array.isArray(j.files)) return j.files;
            if (j[folder] && Array.isArray(j[folder])) return j[folder];
          }
        }catch{}
      }
      try{
        const root = `${OVERLAY_BASE}manifest.json`;
        const r = await fetch(root, { cache:'no-store' });
        if (r.ok && (r.headers.get('content-type')||'').includes('application/json')){
          const j = await r.json();
          if (j && Array.isArray(j[folder])) return j[folder];
        }
      }catch{}
      return null;
    }

    async function listFromAutoIndex(baseUrl){
      try{
        const r = await fetch(baseUrl, { cache:'no-store' });
        const ctype = r.headers.get('content-type') || '';
        if (r.ok && ctype.includes('text/html')){
          const html = await r.text();
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const hrefs = Array.from(doc.querySelectorAll('a[href]')).map(a => a.getAttribute('href') || '');
          const files = hrefs.map(h => h.replace(/^\.\//, '')).filter(h => /\.(png|webp|jpe?g)$/i.test(h));
          return files.length ? files : null;
        }
      }catch{}
      return null;
    }

    async function listFromProbing(baseUrl, cat){
      const prefix = CAT_PREFIX[cat] || 'img';
      const found = [];
      let misses = 0;
      const MAX_MISS_STREAK = 6, MAX_STEPS = 80;
      for (let i=1; i<=MAX_STEPS && misses<MAX_MISS_STREAK; i++){
        let hit = false;
        for (const ext of EXTENSIONS){
          const url = `${baseUrl}${prefix}${i}.${ext}`;
          try{
            const r = await fetch(url, { method:'HEAD', cache:'no-store' });
            if (r.ok){ found.push(`${prefix}${i}.${ext}`); hit = true; break; }
          }catch{}
        }
        misses = hit ? 0 : misses + 1;
      }
      return found.length ? found : null;
    }

    async function listOverlays(cat){
      if (OVERLAY_CACHE[cat]) return OVERLAY_CACHE[cat];
      const folder = resolveFolder(cat);
      const baseUrl = `${OVERLAY_BASE}${folder}/`;

      let files = await listFromManifest(baseUrl, folder);
      if (files && files.length){
        files = files.filter(f => /\.(png|webp|jpe?g)$/i.test(f));
        OVERLAY_CACHE[cat] = files; return files;
      }

      files = await listFromAutoIndex(baseUrl);
      if (files && files.length){ OVERLAY_CACHE[cat] = files; return files; }

      files = await listFromProbing(baseUrl, cat);
      if (files && files.length){ OVERLAY_CACHE[cat] = files; return files; }

      OVERLAY_CACHE[cat] = [];
      return [];
    }

    async function renderShelf(cat){
      overlayShelf.innerHTML = '';
      overlayShelf.setAttribute('aria-busy','true');
      try{
        const files = await listOverlays(cat);
        if (!files.length){
          const msg = document.createElement('div');
          msg.className = 'pill';
          msg.textContent = 'No overlays found in /overlays/' + resolveFolder(cat);
          overlayShelf.appendChild(msg);
          return;
        }
        for (const name of files){
          const div = document.createElement('div');
          div.className = 'olThumb';
          const img = document.createElement('img');
          img.src = resolveSpritePath(cat, name);
          img.alt = `${cat}-${name}`;
          img.onerror = () => { div.style.opacity = .5; div.title = 'Missing: ' + img.src; };
          div.appendChild(img);
          div.onclick = () => addOverlayImage(resolveSpritePath(cat, name));
          overlayShelf.appendChild(div);
        }
      } finally {
        overlayShelf.removeAttribute('aria-busy');
      }
    }

    tabBtns.forEach(btn => {
      btn.onclick = () => {
        tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        renderShelf(btn.dataset.cat);
      };
    });
    if (tabBtns[0]) { tabBtns[0].classList.add('active'); renderShelf(tabBtns[0].dataset.cat); }

    function addOverlayImage(src){
      fabric.Image.fromURL(
        src,
        img => {
          const cw=fabricCanvas.getWidth(), ch=fabricCanvas.getHeight();
          const targetW=cw*0.28;
          const scale=targetW/img.width;
          img.scale(scale);
          img.set({
            left:cw/2-(img.width*scale)/2,
            top:ch/2-(img.height*scale)/2,
            cornerStyle:'circle',
            transparentCorners:false,
            shadow:'rgba(0,0,0,0.35) 0 6px 16px',
            erasable:true
          });
          img._eraseUndoStack=[];
          img._eraseRedoStack=[];
          fabricCanvas.add(img);
          fabricCanvas.setActiveObject(img);
          fabricCanvas.requestRenderAll();
        },
        { crossOrigin:'anonymous' }
      );
    }

    /* Hue/Opacity/Order */
    const supportsHue = !!(fabric.Image && fabric.Image.filters && fabric.Image.filters.HueRotation);
    overlayHue.disabled = !supportsHue;
    function ensureHueFilter(img){ img.filters = img.filters || []; img.filters = img.filters.filter(f => !(f && f.type === 'HueRotation')); }
    overlayHue.oninput = (e)=>{ if(!supportsHue) return; const o=fabricCanvas.getActiveObject(); if(o && o.type==='image' && o!==baseImage){ const deg=parseInt(e.target.value,10)||0; ensureHueFilter(o); if (deg !== 0) o.filters.push(new fabric.Image.filters.HueRotation({ rotation: deg * Math.PI/180 })); o.applyFilters(); fabricCanvas.requestRenderAll(); } };
    overlayOpacity.oninput = (e)=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ o.set('opacity', parseFloat(e.target.value)); fabricCanvas.requestRenderAll(); } };

    bringFront.onclick = ()=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ o.bringToFront(); fabricCanvas.requestRenderAll(); } };
    sendBack.onclick  = ()=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ o.sendToBack(); if(baseImage) baseImage.sendToBack(); fabricCanvas.requestRenderAll(); } };
    deleteObj.onclick = ()=>{ const o=fabricCanvas.getActiveObject(); if(o && o!==baseImage){ fabricCanvas.remove(o); fabricCanvas.discardActiveObject(); fabricCanvas.requestRenderAll(); } };

    /* ===== Text Boxes on Photos ===== */
    function selectedTextbox(){
      const o=fabricCanvas.getActiveObject();
      return (o && o.type==='textbox' && !o.isBaseText) ? o : null;
    }

    addTextbox.onclick = ()=>{
      const tb = new fabric.Textbox('Double-click to edit', {
        left: Math.max(10, (fabricCanvas.getWidth()*0.5)-120),
        top:  Math.max(10, (fabricCanvas.getHeight()*0.5)-30),
        width: 240,
        fontSize: parseInt(tbFont.value,10)||24,
        fill:'#fff',
        backgroundColor: `rgba(0,0,0,${parseFloat(tbBgOpacity.value)||0.6})`,
        padding: 8,
        cornerStyle:'circle',
        transparentCorners:false,
        editable:true
      });
      tb._kind='text';
      fabricCanvas.add(tb);
      fabricCanvas.setActiveObject(tb);
      tbContent.value = tb.text;
      fabricCanvas.requestRenderAll();
    };

    tbApply.onclick = ()=>{
      const tb = selectedTextbox(); if(!tb){ alert('Select a text box first.'); return; }
      tb.set({
        text: tbContent.value,
        fontSize: parseInt(tbFont.value,10)||24,
        backgroundColor: `rgba(0,0,0,${parseFloat(tbBgOpacity.value)||0.6})`
      });
      fabricCanvas.requestRenderAll();
    };
    tbDelete.onclick = ()=>{
      const tb = selectedTextbox(); if(!tb) return;
      fabricCanvas.remove(tb);
      fabricCanvas.discardActiveObject();
      fabricCanvas.requestRenderAll();
    };

    fabricCanvas.on('selection:created', syncTextControls);
    fabricCanvas.on('selection:updated', syncTextControls);
    function syncTextControls(){
      const tb = selectedTextbox();
      if (tb){
        tbContent.value = tb.text||'';
        tbFont.value = tb.fontSize||24;
        const m = tb.backgroundColor||'rgba(0,0,0,0.6)';
        const op = (m.match(/rgba?\([^,]+,[^,]+,[^,]+,([\d.]+)\)/)||[])[1];
        tbBgOpacity.value = op ? parseFloat(op) : 0.6;
      }
    }

    /* ===== Brush / Stamps (Fire, Smoke, Erase) ===== */
    function setStampTag(img, tag){ img.stampTag = tag; img[STAMP_GROUP] = true; }

    brushFire.onclick = ()=> setBrushMode('fire');
    brushSmoke.onclick = ()=> setBrushMode('smoke');
    brushErase.onclick = ()=> setBrushMode('erase');
    brushOff.onclick = ()=> setBrushMode('off');

    async function randomOverlayFile(cat){
      const files = await listOverlays(cat);
      if (!files.length) return null;
      const i = Math.floor(Math.random()*files.length);
      return resolveSpritePath(cat, files[i]);
    }

    function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    async function stampAt(p, cat){
      const file = await randomOverlayFile(cat);
      if (!file) return;
      const R = (parseInt(brushSize.value,10)||120)/2;
      // throttle by distance between stamps
      if (lastStamp && distance(p,lastStamp) < R*0.6) return;
      lastStamp = { x:p.x, y:p.y };

      fabric.Image.fromURL(file, img=>{
        const baseW = img.width||200; // fallback if not yet loaded
        const scale = (R*2) / baseW; // make image approx brush diameter
        const jitter = 0.75 + Math.random()*0.5; // 0.75x .. 1.25x
        img.scale(scale*jitter);
        img.set({
          left: p.x - (img.width*img.scaleX)/2,
          top:  p.y - (img.height*img.scaleY)/2,
          angle: (Math.random()*30 - 15),
          opacity: 0.9,
          cornerStyle:'circle',
          transparentCorners:false,
          erasable:true,
          selectable:false,
          evented:false,
          shadow:'rgba(0,0,0,0.25) 0 4px 12px'
        });
        setStampTag(img, cat); // 'fire' or 'smoke'
        fabricCanvas.add(img);
        img.moveTo( (baseImage ? baseImage.zIndex||0 : 0) + 1 );
        fabricCanvas.requestRenderAll();
      }, { crossOrigin:'anonymous' });
    }

    function eraseStampsAt(p){
      const R = (parseInt(brushSize.value,10)||120)/2;
      const targets = fabricCanvas.getObjects('image').filter(o => o[STAMP_GROUP]);
      for (const obj of targets){
        const cx = obj.left + (obj.width * obj.scaleX)/2;
        const cy = obj.top  + (obj.height* obj.scaleY)/2;
        if (Math.hypot(cx - p.x, cy - p.y) <= R){
          fabricCanvas.remove(obj);
        }
      }
      fabricCanvas.requestRenderAll();
    }

    fabricCanvas.on('mouse:move', (opt)=>{
      const p = fabricCanvas.getPointer(opt.e);
      moveBrushCursor(p);
      if (pointerDown){
        if (brushMode==='fire') stampAt(p, 'fire');
        else if (brushMode==='smoke') stampAt(p, 'smoke');
        else if (brushMode==='erase') eraseStampsAt(p);
      }
    });
    fabricCanvas.on('mouse:down', (opt)=>{
      pointerDown = true;
      const p = fabricCanvas.getPointer(opt.e);
      moveBrushCursor(p);
      if (brushMode==='fire') stampAt(p, 'fire');
      else if (brushMode==='smoke') stampAt(p, 'smoke');
      else if (brushMode==='erase') eraseStampsAt(p);
    });
    fabricCanvas.on('mouse:up', ()=>{ pointerDown = false; });

    /* ===== Legacy Overlay Eraser (clip mask) with visible cursor ===== */
    let erasing=false;
    function selectedOverlay(){ const o=fabricCanvas.getActiveObject(); return (o && o.type==='image' && o!==baseImage) ? o : null; }

    function getMaskCircles(img){
      if (img.clipPath && img.clipPath.type==='group' && img.clipPath.inverted){
        return img.clipPath._objects || [];
      }
      return [];
    }
    function setMaskCircles(img, arr){
      img.set('clipPath', new fabric.Group(arr, { absolutePositioned:true, inverted:true }));
    }
    function pushUndo(img, prevArr){
      img._eraseUndoStack = img._eraseUndoStack || [];
      img._eraseRedoStack = img._eraseRedoStack || [];
      img._eraseUndoStack.push(prevArr.map(c=> new fabric.Circle({left:c.left, top:c.top, radius:c.radius, originX:'center', originY:'center', absolutePositioned:true})));
      img._eraseRedoStack.length = 0;
    }

    function applyCircle(img, p, radius){
      const prev = getMaskCircles(img);
      pushUndo(img, prev);
      const next = prev.slice();
      next.push(new fabric.Circle({ left:p.x, top:p.y, radius, originX:'center', originY:'center', absolutePositioned:true }));
      setMaskCircles(img, next);
    }

    function onMouseDown(opt){
      const img = selectedOverlay(); if(!img) return;
      pointerDown = true;
      const p = fabricCanvas.getPointer(opt.e);
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      applyCircle(img, p, r);
      fabricCanvas.requestRenderAll();
    }
    function onMouseMove(opt){
      if(!pointerDown) return;
      const img = selectedOverlay(); if(!img) return;
      const p = fabricCanvas.getPointer(opt.e);
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      applyCircle(img, p, r);
      fabricCanvas.requestRenderAll();
    }
    function onMouseUp(){ pointerDown=false; }

    function stopErasing(){
      erasing=false; pointerDown=false;
      eraserStatus.textContent='Eraser: off';
      fabricCanvas.off('mouse:down', onMouseDown);
      fabricCanvas.off('mouse:move', onMouseMove);
      fabricCanvas.off('mouse:up', onMouseUp);
      // hide brush cursor if legacy eraser turns off and brush is off
      if (brushMode==='off') showBrushCursor(false);
    }

    eraserStart.onclick = ()=>{
      const img = selectedOverlay(); if(!img){ alert('Select an overlay image first.'); return; }
      // switch brush overlay off while using legacy eraser
      setBrushMode('off');
      ensureBrushCursor();
      showBrushCursor(true);
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      brushCursor.set({ radius:r }); if (brushCursor._inner) brushCursor._inner.set({ radius:Math.max(1,r-2) });
      erasing = true;
      eraserStatus.textContent = `Eraser: ON (size ${parseInt(eraserSize.value,10)||30})`;
      fabricCanvas.on('mouse:down', onMouseDown);
      fabricCanvas.on('mouse:move', onMouseMove);
      fabricCanvas.on('mouse:up', onMouseUp);
    };
    eraserDone.onclick = stopErasing;
    eraserCancel.onclick = ()=>{ stopErasing(); fabricCanvas.renderAll(); };

    eraserSize.oninput = ()=>{
      if (!brushCursor) ensureBrushCursor();
      const r = (parseInt(eraserSize.value,10)||30) * 0.5;
      brushCursor.set({ radius:r }); if (brushCursor._inner) brushCursor._inner.set({ radius:Math.max(1,r-2) });
      if (erasing) eraserStatus.textContent = `Eraser: ON (size ${parseInt(eraserSize.value,10)||30})`;
      fabricCanvas.requestRenderAll();
    };

    eraserOverlayOpacity.oninput = (e)=>{
      const img = selectedOverlay(); if(img){ img.set('opacity', parseFloat(e.target.value)); fabricCanvas.requestRenderAll(); }
    };

    eraserUndo.onclick = ()=>{
      const img = selectedOverlay(); if(!img) return;
      img._eraseUndoStack = img._eraseUndoStack || []; img._eraseRedoStack = img._eraseRedoStack || [];
      const prev = img._eraseUndoStack.pop(); if(!prev) return;
      const curr = getMaskCircles(img);
      img._eraseRedoStack.push(curr.map(c=> new fabric.Circle({left:c.left, top:c.top, radius:c.radius, originX:'center', originY:'center', absolutePositioned:true})));
      setMaskCircles(img, prev);
      fabricCanvas.requestRenderAll();
    };
    eraserRedo.onclick = ()=>{
      const img = selectedOverlay(); if(!img) return;
      img._eraseRedoStack = img._eraseRedoStack || []; img._eraseUndoStack = img._eraseUndoStack || [];
      const nxt = img._eraseRedoStack.pop(); if(!nxt) return;
      const curr = getMaskCircles(img);
      img._eraseUndoStack.push(curr.map(c=> new fabric.Circle({left:c.left, top:c.top, radius:c.radius, originX:'center', originY:'center', absolutePositioned:true})));
      setMaskCircles(img, nxt);
      fabricCanvas.requestRenderAll();
    };
    eraserClear.onclick = ()=>{
      const img = selectedOverlay(); if(!img) return;
      const curr = getMaskCircles(img);
      pushUndo(img, curr);
      setMaskCircles(img, []);
      fabricCanvas.requestRenderAll();
    };

    /* Flip */
    function flipSelected(axis){ const o=fabricCanvas.getActiveObject(); if(!o || o===baseImage) return; if(axis==='x') o.set('flipX', !o.flipX); if(axis==='y') o.set('flipY', !o.flipY); fabricCanvas.requestRenderAll(); }
    flipSelH.onclick=()=>flipSelected('x');
    flipSelV.onclick=()=>flipSelected('y');

    /* Canvas utilities */
    const rebase=()=>{ if(!baseImage) return;
      if (baseImage.type === 'image') setBaseImageFromDataURL(baseImage.toDataURL({}));
      if (baseImage.type === 'rect') {
        const bt = fabricCanvas.getObjects('textbox').find(o=>o.isBaseText);
        setBaseAsTextSlide(bt ? bt.text : '', bt ? bt.fontSize : 34);
      }
    };
    fitBtn.onclick=rebase;
    zoomIn.onclick=()=>fabricCanvas.setZoom(fabricCanvas.getZoom()*1.1);
    zoomOut.onclick=()=>fabricCanvas.setZoom(fabricCanvas.getZoom()/1.1);
    rotateL.onclick=()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)-90); fabricCanvas.requestRenderAll(); } };
    rotateR.onclick=()=>{ if(baseImage && baseImage.rotate){ baseImage.rotate((baseImage.angle||0)+90); fabricCanvas.requestRenderAll(); } };

    /* Delete stop */
    deleteStop.onclick=async()=>{ try{
      if(!current || stopIndex<0) return;
      if(!confirm('Delete this photo/slide from the scenario?')) return;
      const next=[...current._stops];
      next.splice(stopIndex,1);
      const updated={ ...current._raw };
      setStops(updated, next);
      await set(ref(db, `${ROOT}/${current.id}`), updated);
      current._stops=next; stopIndex=-1;
      fabricCanvas.clear(); baseImage=null;
      renderStopsThumbs();
      metaMsg.textContent='Photo/slide deleted.';
    }catch(e){ metaMsg.textContent=String(e.message||e); } };

    // Defaults
    setBrushMode('off');
    ensureBrushCursor(); showBrushCursor(false);

  })().catch(e=>ERR(e?.message||e));
  </script>
</body>
</html>

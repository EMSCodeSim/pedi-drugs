<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FireOps SIM ‚Äî Scenario Builder</title>
</head>
<body>
<header>FireOps SIM ‚Äî Scenario Builder</header>

<main>
  <!-- STEP 1: Create Scenario -->
  <section id="step1">
    <h2>Step 1 ‚Äî Create Scenario</h2>
    <label>Scenario Name *</label>
    <input id="scName" type="text" placeholder="Example: 2-story house, smoke from roof" required />
    <label>Dispatch Info (optional)</label>
    <textarea id="scDispatch" placeholder="E184, 123 Main St, smoke from roof, hydrant at 1st &amp; Oak"></textarea>

    <div id="authStatus" style="margin-top:6px;font-size:.9rem;color:#a9b8e8">Auth: (signing in‚Ä¶)</div>
    <div id="geoStatus" style="font-size:.9rem;color:#a9b8e8;margin-top:4px">Location: (checking‚Ä¶)</div>

    <div style="margin-top:10px">
      <button id="btnCreateScenario">Create Scenario</button>
    </div>
  </section>

  <!-- STEP 2: Add Photo -->
  <section id="step2" hidden>
    <h2>Step 2 ‚Äî Add Photo (+ GPS)</h2>

    <div class="file-row">
      <label class="btn">
        <input id="fileCamera" type="file" accept="image/*" capture="environment" hidden />
        üì∑ Take Photo
      </label>
      <label class="btn">
        <input id="fileLibrary" type="file" accept="image/*" hidden />
        üñºÔ∏è Choose From Library
      </label>
      <button id="btnRefreshGPS" class="btn">‚Üª Refresh GPS</button>
    </div>

    <label>Geofence radius for this photo (meters)</label>
    <input id="photoRadius" type="number" value="5" min="1" />

    <figure id="previewBox">
      <img id="preview" alt="Preview" />
      <figcaption id="previewMeta"></figcaption>
    </figure>

    <div id="progress" class="progress" hidden><div></div></div>

    <div style="margin-top:8px">
      <button id="btnSavePhoto" disabled>Save Photo to Cloud</button>
    </div>
  </section>

  <!-- Thumbs -->
  <section id="photos" hidden>
    <h3>Photos in this Scenario</h3>
    <div id="thumbs" class="thumbs"></div>
  </section>
</main>

<script type="module">
/* ---------------- Firebase ---------------- */
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
import { getStorage, ref as sRef, uploadBytesResumable, getDownloadURL, updateMetadata } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js';
import { getDatabase, ref as dRef, push, set, update, onChildAdded } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

/* Replace with your config (or import your existing app from ./firebase-init.js) */
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_AUTH_DOMAIN",
  databaseURL: "YOUR_DB_URL",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_STORAGE_BUCKET",
  appId: "YOUR_APP_ID"
};
// If you already have firebase-init.js exporting `app`, you can:
// import { app } from './firebase-init.js';
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const storage = getStorage(app);
const db = getDatabase(app);

/* ---------------- Elements ---------------- */
const step1 = document.getElementById('step1');
const step2 = document.getElementById('step2');
const photosSection = document.getElementById('photos');

const scName = document.getElementById('scName');
const scDispatch = document.getElementById('scDispatch');
const btnCreate = document.getElementById('btnCreateScenario');
const authStatus = document.getElementById('authStatus');
const geoStatus = document.getElementById('geoStatus');

const fileCamera = document.getElementById('fileCamera');
const fileLibrary = document.getElementById('fileLibrary');
const preview = document.getElementById('preview');
const previewMeta = document.getElementById('previewMeta');
const btnSavePhoto = document.getElementById('btnSavePhoto');
const btnRefreshGPS = document.getElementById('btnRefreshGPS');
const photoRadius = document.getElementById('photoRadius');

const progress = document.getElementById('progress');
const progressBar = progress.querySelector('div');
const thumbs = document.getElementById('thumbs');

/* ---------------- State ---------------- */
let scenarioId = null;
let pendingFile = null;
let lastLocation = null;
let authed = false;

/* ---------------- Auth (fixes create-scenario failures) ---------------- */
function ensureAuth() {
  return new Promise((resolve) => {
    if (authed) return resolve();
    signInAnonymously(auth).catch(() => {/* handled by onAuthStateChanged */});
    const unsub = onAuthStateChanged(auth, (user) => {
      if (user) {
        authed = true;
        authStatus.textContent = `Auth: anonymous ‚úì`;
        unsub();
        resolve();
      } else {
        authStatus.textContent = `Auth: (not signed in)`;
      }
    });
  });
}

/* ---------------- Geolocation ---------------- */
function formatLoc(loc) {
  if (!loc) return 'Location: (pending‚Ä¶)';
  const { coords } = loc;
  return `Location: ${coords.latitude.toFixed(6)}, ${coords.longitude.toFixed(6)} (¬±${Math.round(coords.accuracy)}m at ${new Date(loc.timestamp).toLocaleTimeString()})`;
}
function getLocationOnce() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('Geolocation unsupported'));
    navigator.geolocation.getCurrentPosition(resolve, reject, {
      enableHighAccuracy: true, maximumAge: 10_000, timeout: 15_000
    });
  });
}
async function refreshLocationUI() {
  try {
    lastLocation = await getLocationOnce();
    geoStatus.textContent = formatLoc(lastLocation);
  } catch (e) {
    // Do not block flows on location failure
    geoStatus.textContent = 'Location: unavailable (' + e.message + ')';
  }
}

/* ---------------- Image Downscale ---------------- */
async function downscaleToJpeg(file, maxDim = 1800, quality = 0.78) {
  try {
    const bitmap = await createImageBitmap(file);
    const scale = Math.min(1, maxDim / Math.max(bitmap.width, bitmap.height));
    const w = Math.round(bitmap.width * scale);
    const h = Math.round(bitmap.height * scale);
    const canvas = ('OffscreenCanvas' in window) ? new OffscreenCanvas(w, h) : Object.assign(document.createElement('canvas'), { width: w, height: h });
    if (!('OffscreenCanvas' in window)) { canvas.width = w; canvas.height = h; }
    const ctx = canvas.getContext('2d', { alpha: false });
    ctx.drawImage(bitmap, 0, 0, w, h);
    const blob = await (('convertToBlob' in canvas) ? canvas.convertToBlob({ type: 'image/jpeg', quality }) : new Promise(res => canvas.toBlob(res, 'image/jpeg', quality)));
    if (bitmap.close) bitmap.close();
    return { blob, w, h };
  } catch {
    // Fallback
    const url = URL.createObjectURL(file);
    const img = document.createElement('img');
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
    const scale = Math.min(1, maxDim / Math.max(img.naturalWidth, img.naturalHeight));
    const w = Math.round(img.naturalWidth * scale);
    const h = Math.round(img.naturalHeight * scale);
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d', { alpha: false });
    ctx.drawImage(img, 0, 0, w, h);
    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality));
    URL.revokeObjectURL(url);
    return { blob, w, h };
  }
}
const makeThumbnail = (file) => downscaleToJpeg(file, 400, 0.7);

/* ---------------- Upload Flow (radius per photo) ---------------- */
async function uploadPhotoSet(scenarioId, file, loc, radiusMeters) {
  const [main, thumb] = await Promise.all([downscaleToJpeg(file, 1800, 0.78), makeThumbnail(file)]);
  const basePath = `fireops/${scenarioId}/${Date.now()}`;
  const mainRef = sRef(storage, `${basePath}.jpg`);
  const thumbRef = sRef(storage, `${basePath}_400.jpg`);
  const meta = { contentType: 'image/jpeg', cacheControl: 'public, max-age=86400, immutable' };

  progress.hidden = false; progressBar.style.width = '0%';

  const mainTask = uploadBytesResumable(mainRef, main.blob, meta);
  const thumbTask = uploadBytesResumable(thumbRef, thumb.blob, meta);

  mainTask.on('state_changed', s => {
    const pct = Math.round(100 * s.bytesTransferred / s.totalBytes);
    progressBar.style.width = `${pct}%`;
  });

  const [_, __] = await Promise.all([
    new Promise(res => mainTask.on('state_changed', null, null, () => res())),
    new Promise(res => thumbTask.on('state_changed', null, null, () => res())),
  ]);

  const [url, thumbUrl] = await Promise.all([getDownloadURL(mainRef), getDownloadURL(thumbRef)]);
  await Promise.all([updateMetadata(mainRef, meta), updateMetadata(thumbRef, meta)]);

  const photoKey = mainRef.name.replace('.jpg', '');
  const photoData = {
    url, thumbUrl,
    w: main.w, h: main.h,
    createdAt: Date.now(),
    gps: loc ? { lat: loc.coords.latitude, lng: loc.coords.longitude, accuracy: loc.coords.accuracy, ts: loc.timestamp } : null,
    radiusMeters: Number(radiusMeters) || 5
  };

  await update(dRef(db, `/scenarios/${scenarioId}/photos/${photoKey}`), photoData);
  return { url, thumbUrl, key: photoKey, w: main.w, h: main.h };
}

/* ---------------- Thumbnails listener ---------------- */
function startThumbListener(scenarioId) {
  photosSection.hidden = false;
  const photosRef = dRef(db, `/scenarios/${scenarioId}/photos`);
  onChildAdded(photosRef, (snap) => {
    const v = snap.val();
    const card = document.createElement('a');
    card.className = 'thumb';
    card.href = v.url; card.target = '_blank';
    card.innerHTML = `
      <img loading="lazy" src="${v.thumbUrl || v.url}" alt="thumb">
      <div class="meta">
        <div>${new Date(v.createdAt).toLocaleString()}</div>
        <div>${v.w}√ó${v.h} ‚Ä¢ ${v.radiusMeters ?? '‚Äî'} m</div>
      </div>`;
    thumbs.prepend(card);
  });
}

/* ---------------- Events ---------------- */
btnCreate.addEventListener('click', async () => {
  const name = scName.value.trim();
  if (!name) { alert('Please enter a scenario name.'); return; }

  btnCreate.disabled = true;

  try {
    await ensureAuth();                    // <-- important fix
    if (!lastLocation) await refreshLocationUI(); // non-blocking if it fails

    const scenariosRef = dRef(db, '/scenarios');
    const newRef = push(scenariosRef);
    scenarioId = newRef.key;

    const payload = {
      name,
      dispatch: scDispatch.value.trim() || null,
      createdAt: Date.now(),
      source: 'builder-web'
      // No radius here; radius is saved per photo
    };

    await set(newRef, payload);

    scName.disabled = scDispatch.disabled = true;
    step2.hidden = false;
    startThumbListener(scenarioId);
  } catch (e) {
    console.error('Create scenario failed:', e);
    alert('Unable to create scenario: ' + (e?.message || e));
    btnCreate.disabled = false;
  }
});

[fileCamera, fileLibrary].forEach(input => input.addEventListener('change', () => {
  const f = input.files?.[0];
  if (!f) return;
  pendingFile = f;
  const url = URL.createObjectURL(f);
  preview.src = url;
  preview.onload = () => URL.revokeObjectURL(url);
  previewMeta.textContent = `${f.name} ‚Äî ${(f.size/1024/1024).toFixed(2)} MB`;
  btnSavePhoto.disabled = false;
}));

btnSavePhoto.addEventListener('click', async () => {
  if (!scenarioId) { alert('Create the scenario first.'); return; }
  if (!pendingFile) { alert('Choose or take a photo first.'); return; }
  btnSavePhoto.disabled = true;
  try {
    await ensureAuth();              // defensive
    await refreshLocationUI();       // best-effort
    await uploadPhotoSet(scenarioId, pendingFile, lastLocation, photoRadius.value);
    previewMeta.textContent = 'Saved ‚úî';
  } catch (e) {
    console.error(e);
    alert('Upload failed: ' + e.message);
  } finally {
    progress.hidden = true; progressBar.style.width = '0%';
    btnSavePhoto.disabled = false;
    pendingFile = null;
  }
});

btnRefreshGPS.addEventListener('click', refreshLocationUI);
/* Kick off auth+location early */
ensureAuth().then(refreshLocationUI);
</script>

<style>
:root { --bg:#0b1020; --card:#121a2f; --accent:#4ad; --text:#eaf1ff; --muted:#9ab; }
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--text)}
header{position:sticky;top:0;background:linear-gradient(90deg,#0b1020,#16254a);padding:12px 16px;font-weight:700;letter-spacing:.2px;border-bottom:1px solid #1f2b4d}
main{padding:16px;max-width:960px;margin:0 auto}
section{background:var(--card);border:1px solid #1f2b4d;border-radius:16px;padding:16px;margin-bottom:16px;box-shadow:0 4px 24px rgba(0,0,0,.25)}
h2,h3{margin:0 0 12px 0;font-size:1.1rem;color:#dfe9ff}
label{display:block;margin:10px 0 6px 2px;font-size:.92rem;color:#cdd8f7}
input[type=text],input[type=number],textarea{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #2a3a66;background:#0f1730;color:var(--text);outline:none}
textarea{min-height:80px;resize:vertical}
.btn, button{display:inline-block;background:#1a2a52;border:1px solid #27407a;color:#dfe9ff;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600;user-select:none}
.btn:hover,button:hover{filter:brightness(1.1)}
.btn:disabled,button:disabled{opacity:.6;cursor:not-allowed}
.file-row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
#previewBox{margin:8px 0;border-radius:14px;overflow:hidden;border:1px solid #23335f}
#preview{width:100%;max-height:60vh;object-fit:contain;display:block;background:#0d142b}
#progress{height:10px;background:#0e1a34;border-radius:8px;overflow:hidden;margin:8px 0;border:1px solid #24355f}
#progress>div{height:100%;width:0%;background:linear-gradient(90deg,#2a7ae2,#4ad)}
.thumbs{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px}
.thumb{display:block;border:1px solid #23335f;border-radius:12px;overflow:hidden;text-decoration:none;color:inherit;background:#0d142b}
.thumb img{width:100%;height:90px;object-fit:cover;display:block}
.thumb .meta{padding:6px 8px;font-size:.72rem;color:#a9b8e8}
</style>
</body>
</html>
